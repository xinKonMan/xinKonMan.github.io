<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>剑指Offer算法学习 | xinKonMan</title><meta name="author" content="xinKon,842406009@qq.com"><meta name="copyright" content="xinKon"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="针对在力扣中的剑指Offer算法模块的学习记录，记录了各个问题的解决思路方案">
<meta property="og:type" content="article">
<meta property="og:title" content="剑指Offer算法学习">
<meta property="og:url" content="https://xinkonman.github.io/2022/11/17/%E5%89%91%E6%8C%87Offer%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/index.html">
<meta property="og:site_name" content="xinKonMan">
<meta property="og:description" content="针对在力扣中的剑指Offer算法模块的学习记录，记录了各个问题的解决思路方案">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.statically.io/gh/xinKonMan/cdn/main/static/jianzhiOffer.jpg">
<meta property="article:published_time" content="2022-11-17T09:52:12.792Z">
<meta property="article:modified_time" content="2022-11-18T09:38:59.491Z">
<meta property="article:author" content="xinKon">
<meta property="article:tag" content="算法">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.statically.io/gh/xinKonMan/cdn/main/static/jianzhiOffer.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://xinkonman.github.io/2022/11/17/%E5%89%91%E6%8C%87Offer%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":200},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"bottom-left"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '剑指Offer算法学习',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-11-18 17:38:59'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/custom.css" media="defer" onload="this.media='all'"><!-- hexo injector head_end start --><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-categories-card@1.0.0/lib/categorybar.css"><link rel="stylesheet" href="https://cdn.statically.io/gh/xinKonMan/cdn/main/css/runtime.min.css" media="print" onload="this.media='all'"><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/pace-js/themes/blue/pace-theme-minimal.min.css"/><script src="https://cdn.jsdelivr.net/npm/pace-js/pace.min.js"></script><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.statically.io/gh/xinKonMan/cdn/main/img/anchor.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">7</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">5</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">3</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group hide" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://cdn.statically.io/gh/xinKonMan/cdn/main/static/jianzhiOffer.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">xinKonMan</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group hide" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">剑指Offer算法学习</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-11-17T09:52:12.792Z" title="发表于 2022-11-17 17:52:12">2022-11-17</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-11-18T09:38:59.491Z" title="更新于 2022-11-18 17:38:59">2022-11-18</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/">算法学习</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="剑指Offer算法学习"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="剑指Offer"><a href="#剑指Offer" class="headerlink" title="剑指Offer"></a>剑指Offer</h2><h4 id="Day03"><a href="#Day03" class="headerlink" title="Day03"></a>Day03</h4><h5 id="剑指Offer0-5替换空格"><a href="#剑指Offer0-5替换空格" class="headerlink" title="剑指Offer0.5替换空格"></a>剑指Offer0.5替换空格</h5><p>请实现一个函数，把字符串 <code>s</code> 中的每个空格替换成”%20”。</p>
<p><strong>字符串为不可变对象</strong></p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;We are happy.&quot;</span><br><span class="line">输出：&quot;We%20are%20happy.&quot;</span><br></pre></td></tr></table></figure>

<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/ti-huan-kong-ge-lcof/">https://leetcode-cn.com/problems/ti-huan-kong-ge-lcof/</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h6 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a><strong>知识点</strong></h6><p>运用到String的<code>toCharArray()</code> 可以将字符串转换成字符数组</p>
<p>字符之间的拼接用StringBuffer,<code>append()</code>方法可以添加字符串或者字符</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">replaceSpace</span><span class="params">(String s)</span> &#123;</span><br><span class="line">      <span class="type">StringBuffer</span> <span class="variable">res</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">      <span class="keyword">for</span>(Character c:s.toCharArray())&#123;</span><br><span class="line">          <span class="keyword">if</span>(c==<span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">              res.append(<span class="string">&quot;%20&quot;</span>);</span><br><span class="line">          &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">              res.append(c);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> res.toString();</span><br><span class="line">   	<span class="comment">//String中的replace方法</span></span><br><span class="line">      <span class="comment">/*String res =  s.replace(&quot; &quot;,&quot;%20&quot;);</span></span><br><span class="line"><span class="comment">      return res;*/</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>



<h5 id="剑指Offer58-左旋转字符串"><a href="#剑指Offer58-左旋转字符串" class="headerlink" title="剑指Offer58- ||.左旋转字符串"></a>剑指Offer58- ||.左旋转字符串</h5><p>字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。请定义一个函数实现字符串左旋转操作的功能。比如，输入字符串”abcdefg”和数字2，该函数将返回左旋转两位得到的结果”cdefgab”。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;abcdefg&quot;, k = 2</span><br><span class="line">输出: &quot;cdefgab&quot;</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;lrloseumgh&quot;, k = 6</span><br><span class="line">输出: &quot;umghlrlose&quot;</span><br></pre></td></tr></table></figure>

<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof">https://leetcode-cn.com/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h6 id="知识点-1"><a href="#知识点-1" class="headerlink" title="知识点"></a><strong>知识点</strong></h6><p>String中的<code>subString()</code>切片函数。返回字符串的子字符串，参数为索引。</p>
<p><strong>StingBuffer和StringBuffer区别：</strong></p>
<ol>
<li><p>StringBuilder 的方法不是线程安全的（不能同步访问）。</p>
</li>
<li><p>StringBuilder 相较于 StringBuffer 有速度优势，<strong>所以多数情况下建议使用 StringBuilder 类</strong>。</p>
</li>
</ol>
<p><strong>方法一：字符串切片</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">reverseLeftWords</span><span class="params">(String s, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> s.substring(n, s.length()) + s.substring(<span class="number">0</span>, n);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p><strong>方法二：列表遍历拼接</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">reverseLeftWords</span><span class="params">(String s, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">       <span class="type">StringBuilder</span> <span class="variable">res</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n; i &lt; s.length(); i++)</span><br><span class="line">           res.append(s.charAt(i));</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">           res.append(s.charAt(i));</span><br><span class="line">       <span class="keyword">return</span> res.toString();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//取余化简。妙啊</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">reverseLeftWords</span><span class="params">(String s, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">       <span class="type">StringBuilder</span> <span class="variable">res</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n; i &lt; n + s.length(); i++)</span><br><span class="line">           res.append(s.charAt(i % s.length()));</span><br><span class="line">       <span class="keyword">return</span> res.toString();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p><strong>方法二：字符串遍历拼接(只能用String时)</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">	<span class="keyword">public</span> String <span class="title function_">reverseLeftWords</span><span class="params">(String s, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">       <span class="type">String</span> <span class="variable">res</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n; i &lt; s.length(); i++)</span><br><span class="line">           res += s.charAt(i);</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">           res += s.charAt(i);</span><br><span class="line">       <span class="keyword">return</span> res;</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">//取余化简代码</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">reverseLeftWords</span><span class="params">(String s, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">       <span class="type">String</span> <span class="variable">res</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n; i &lt; n + s.length(); i++)</span><br><span class="line">           res += s.charAt(i % s.length());</span><br><span class="line">       <span class="keyword">return</span> res;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="Day04"><a href="#Day04" class="headerlink" title="Day04"></a>Day04</h4><h5 id="剑指Offer03-数组中重复的数字"><a href="#剑指Offer03-数组中重复的数字" class="headerlink" title="剑指Offer03.数组中重复的数字"></a>剑指Offer03.数组中重复的数字</h5><p>找出数组中重复的数字。</p>
<p>在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">[2, 3, 1, 0, 2, 5, 3]</span><br><span class="line">输出：2 或 3 </span><br></pre></td></tr></table></figure>

<h6 id="知识点-2"><a href="#知识点-2" class="headerlink" title="知识点"></a><strong>知识点</strong></h6><p>可以用哈希表来做。直接使用是否contain方法查看是否包含，有包含则重复出现</p>
<p><strong>HashSet基于 HashMap 来实现的，是一个不允许有重复元素的集合。</strong></p>
<p>HashSet 允许有 null 值。</p>
<p>HashSet 是无序的，即不会记录插入的顺序。</p>
<p>HashSet主要针对单一元素。<code>add()</code>重复元素不会被添加。</p>
<p>使用原地条件主要条件**在一个长度为 n 的数组 nums 里的所有数字都在 0 ~ n-1 的范围内。数组元素的 **索引和 值 是 <strong>一对多</strong> 的关系。</p>
<p>该方法不用占用空间。空间复杂度为O(1)。</p>
<p><strong>方法一：哈希表&#x2F;set</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">findRepeatNumber1</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    HashSet&lt;Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">        <span class="keyword">if</span> (map.contains(num)) &#123;</span><br><span class="line">            <span class="keyword">return</span> num;</span><br><span class="line">        &#125;</span><br><span class="line">        map.add(num);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>方法二：原地交换</strong></p>
<p>题目说明尚未被充分使用，即 <code>在一个长度为 n 的数组 nums 里的所有数字都在 0 ~ n-1 的范围内 </code>。 此说明含义：数组元素的 <strong>索引</strong> 和 值 是 <strong>一对多</strong> 的关系。<br>因此，可遍历数组并通过交换操作，使元素的 <strong>索引</strong> 与 <strong>值</strong> 一一对应（即 nums[i] &#x3D; i）。因而，就能通过索引映射对应的值，起到与字典等价的作用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">findRepeatNumber</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">   		<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; nums.length) &#123;</span><br><span class="line">            <span class="comment">//说明数字已经在对应的索引位置上。</span></span><br><span class="line">            <span class="keyword">if</span> (nums[i] == i) &#123;</span><br><span class="line">                i++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//判断索引值为nums[i]上是否存在于当前nums[i]相等的值，即找到一组重复值</span></span><br><span class="line">            <span class="keyword">if</span> (nums[nums[i]] == nums[i]) &#123;</span><br><span class="line">                <span class="keyword">return</span> nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//将该元素交换到与之相等的索引位置上</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> nums[i];</span><br><span class="line">            nums[i] = nums[temp];</span><br><span class="line">            nums[temp] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="剑指Offer53-在排序数组中查找数字"><a href="#剑指Offer53-在排序数组中查找数字" class="headerlink" title="剑指Offer53-|.在排序数组中查找数字|"></a>剑指Offer53-|.在排序数组中查找数字|</h5><p>统计一个数字在排序数组中出现的次数。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [5,7,7,8,8,10], target = 8</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [5,7,7,8,8,10], target = 6</span><br><span class="line">输出: 0</span><br></pre></td></tr></table></figure>

<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/zai-pai-xu-shu-zu-zhong-cha-zhao-shu-zi-lcof">https://leetcode-cn.com/problems/zai-pai-xu-shu-zu-zhong-cha-zhao-shu-zi-lcof</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h6 id="知识点-3"><a href="#知识点-3" class="headerlink" title="知识点"></a><strong>知识点</strong></h6><p><strong>排序数组</strong>中的<strong>搜索问题</strong>，首先想到 <strong>二分法</strong> 解决。</p>
<p>通过二分法找到target个数数组的<strong>左边界left</strong>和<strong>右边界right</strong>。应用了<strong>两次二分法</strong>可以得到target的数量为<code>right-left-1</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">       <span class="comment">//第一次二分</span></span><br><span class="line">       <span class="comment">// 搜索右边界 right</span></span><br><span class="line">       <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = nums.length - <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">while</span>(i &lt;= j) &#123;</span><br><span class="line">           <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> (i + j) / <span class="number">2</span>;</span><br><span class="line">           <span class="keyword">if</span>(nums[m] &lt;= target) i = m + <span class="number">1</span>;</span><br><span class="line">           <span class="keyword">else</span> j = m - <span class="number">1</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//找到右边界下标</span></span><br><span class="line">       <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> i;</span><br><span class="line">       <span class="comment">//此时的j在i的前面，即有右边界的前面，所有如果j位置上的不等于目标值，说明没有该数</span></span><br><span class="line">       <span class="comment">//若数组中无 target ，则提前返回</span></span><br><span class="line">       <span class="keyword">if</span>(j &gt;= <span class="number">0</span> &amp;&amp; nums[j] != target) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">       <span class="comment">//第二次二分</span></span><br><span class="line">       <span class="comment">// 搜索左边界 right</span></span><br><span class="line">       i = <span class="number">0</span>; j = nums.length - <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">while</span>(i &lt;= j) &#123;</span><br><span class="line">           <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> (i + j) / <span class="number">2</span>;</span><br><span class="line">           <span class="keyword">if</span>(nums[m] &lt; target) i = m + <span class="number">1</span>;</span><br><span class="line">           <span class="keyword">else</span> j = m - <span class="number">1</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> j;</span><br><span class="line">       <span class="keyword">return</span> right - left - <span class="number">1</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>



<h5 id="剑指-Offer-53-II-0～n-1中缺失的数字"><a href="#剑指-Offer-53-II-0～n-1中缺失的数字" class="headerlink" title="剑指 Offer 53 - II. 0～n-1中缺失的数字"></a>剑指 Offer 53 - II. 0～n-1中缺失的数字</h5><p>一个长度为n-1的递增排序数组中的所有数字都是唯一的，并且每个数字都在范围0～n-1之内。在范围0～n-1内的n个数字中有且只有一个数字不在该数组中，请找出这个数字。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [0,1,3]</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [0,1,2,3,4,5,6,7,9]</span><br><span class="line">输出: 8</span><br></pre></td></tr></table></figure>

<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/que-shi-de-shu-zi-lcof">https://leetcode-cn.com/problems/que-shi-de-shu-zi-lcof</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h6 id="知识点-4"><a href="#知识点-4" class="headerlink" title="知识点"></a><strong>知识点</strong></h6><p>主要点是缺失的数字等于<strong>“右子数组的首位元素”</strong> 对应的索引。因此考虑使用二分法查找 “右子数组的首位元素” 。</p>
<p>即是找到右边界</p>
<p>排序数组使用<strong>双指针和二分法</strong>是高频选择</p>
<p>二分法时，循环的最后j始终在i的左边。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">missingNumber</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">       <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = nums.length - <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">while</span>(i &lt;= j) &#123;</span><br><span class="line">           <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> (i + j) / <span class="number">2</span>;</span><br><span class="line">           <span class="keyword">if</span>(nums[m] == m) i = m + <span class="number">1</span>;</span><br><span class="line">           <span class="keyword">else</span> j = m - <span class="number">1</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> i;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>



<h4 id="Day05"><a href="#Day05" class="headerlink" title="Day05"></a>Day05</h4><h5 id="剑指-Offer-04-二维数组中的查找"><a href="#剑指-Offer-04-二维数组中的查找" class="headerlink" title="剑指 Offer 04. 二维数组中的查找"></a>剑指 Offer 04. 二维数组中的查找</h5><p>在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个高效的函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p>
<p> 示例:</p>
<p>现有矩阵 matrix 如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [1,   4,  7, 11, 15],</span><br><span class="line">  [2,   5,  8, 12, 19],</span><br><span class="line">  [3,   6,  9, 16, 22],</span><br><span class="line">  [10, 13, 14, 17, 24],</span><br><span class="line">  [18, 21, 23, 26, 30]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>给定 target &#x3D; 5，返回 true。</p>
<p>给定 target &#x3D; 20，返回 false。</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof">https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h6 id="知识点-5"><a href="#知识点-5" class="headerlink" title="知识点"></a><strong>知识点</strong></h6><p>若使用暴力法遍历矩阵 <code>matrix</code> ，则时间复杂度为 O(NM) 。暴力法未利用矩阵 <strong>“从上到下递增、从左到右递增”</strong> 的特点，</p>
<p>显然不是最优解法。</p>
<p>我们将矩阵逆时针旋转 45° ，并将其转化为图形式，发现其类似于 <strong>二叉搜索树</strong> ，即对于每个元素，其左分支元素更小、右分支元素更大。因此，通过从 “根节点” 开始搜索，遇到比 <code>target</code> 大的元素就向左，反之向右，即可找到目标值 <code>target</code> 。</p>
<p>若<strong>行索引或列索引越界</strong>，则代表矩阵中无目标值，返回 <em>f<strong>a</strong>l<strong>s</strong>e</em> </p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.leetcode-cn.com/6584ea93812d27112043d203ea90e4b0950117d45e0452d0c630fcb247fbc4af-Picture1.png" alt="Picture1.png"></p>
<p>“根节点” 对应的是矩阵的 “左下角” 和 “右上角” 元素，本文称之为 <strong>标志数</strong> ，以 <code>matrix </code>中的 <strong>左下角元素</strong> 为标志数 <code>flag </code>，则有:</p>
<p>若<code>flag &gt; target</code>，则 <code>target </code>一定在 <code>flag </code>所在 行的上方 ，即<code>flag</code>所在行可被消去。<br>若 <code>flag &lt; target </code>，则 <code>target </code>一定在<code> flag</code> 所在 列的右方 ，即<code>flag</code>所在列可被消去。</p>
<p><strong>方法一：暴力解法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">findNumberIn2DArray</span><span class="params">(<span class="type">int</span>[][] matrix, <span class="type">int</span> target)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (matrix == <span class="literal">null</span> || matrix.length == <span class="number">0</span> || matrix[<span class="number">0</span>].length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; matrix.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; matrix[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (matrix[i][j] == target) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>方法二：利用标志数求解</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">findNumberIn2DArray</span><span class="params">(<span class="type">int</span>[][] matrix, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="comment">//从二维数组的左下角开始往上走。</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> matrix.length - <span class="number">1</span>, j = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//行索引或列索引越界，则跳出循环</span></span><br><span class="line">        <span class="keyword">while</span> (i &gt;= <span class="number">0</span> &amp;&amp; j &lt; matrix[<span class="number">0</span>].length) &#123;</span><br><span class="line">            <span class="comment">//设置矩阵左下角为标志数</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">flag</span> <span class="operator">=</span> matrix[i][j];</span><br><span class="line">            <span class="keyword">if</span> (target &lt; flag) &#123;</span><br><span class="line">                <span class="comment">//消去一列</span></span><br><span class="line">                i--;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (target &gt; flag) &#123;</span><br><span class="line">                <span class="comment">//消去一行</span></span><br><span class="line">                j++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度O(N+M)：其中，N<em>N</em> 和 M<em>M</em> 分别为矩阵行数和列数，此算法最多循环 M+N次。</p>
<p>空间复杂度O(1)。</p>
<h5 id="二分法："><a href="#二分法：" class="headerlink" title="二分法："></a>二分法：</h5><p>仔细看题（解题的关键在认真读题），<strong>分析清楚题目要找的答案需要满足什么性质。采用两边夹的方式，每一轮把待搜索区间分成两个部分，排除掉一定不是答案的区间，最后左右指针重合的地方就是我们要找的元素。</strong></p>
<p>即是要分清搜索区间是在哪。<strong>在于我们能够根据题意：得到某种单调性，和可以逐步缩小搜索规模的条件，进而准确地设计可以使得搜索区间缩小的条件</strong>。只看到 while (left &lt; right) 里的 &lt; ，不能说明右边界不能取到。真正看区间表示应该看左右边界到底如何设置，如果我们分析出下一轮搜索的范围是 [left..mid] 而设置 right &#x3D; mid + 1，才表示搜索区间为「左闭右开」区间 。这是因为 [left..right) &#x3D; [left..mid + 1) &#x3D; [left..mid]。</p>
<p><strong>while (left &lt;&#x3D; right) 表示在区间里只剩下一个元素的时候，我们还需要继续查找</strong>，因此循环可以继续的条件是 left &lt;&#x3D; right，这一行代码对应了二分查找算法的思路 1：在循环体中查找元素。</p>
<h5 id="剑指-Offer-11-旋转数组的最小数字"><a href="#剑指-Offer-11-旋转数组的最小数字" class="headerlink" title="剑指 Offer 11. 旋转数组的最小数字"></a>剑指 Offer 11. 旋转数组的最小数字</h5><p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。例如，数组 [3,4,5,1,2] 为 [1,2,3,4,5] 的一个旋转，该数组的最小值为1。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：[3,4,5,1,2]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：[2,2,2,0,1]</span><br><span class="line">输出：0 </span><br></pre></td></tr></table></figure>

<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof">https://leetcode-cn.com/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h6 id="知识点-6"><a href="#知识点-6" class="headerlink" title="知识点"></a><strong>知识点</strong></h6><p>递增排序的数组的一个旋转的特性：<strong>该数组的最小值一定是数组旋转过去后的第一个数</strong>。</p>
<p>排序数组的查找问题首先考虑的是<strong>二分法</strong>解决。其可将 <strong>遍历法</strong> 的 <strong>线性级别</strong> 时间复杂度降低至 <strong>对数级别</strong> 。</p>
<p><strong>当numbers[mid] &#x3D; numbers[j]时，只需要j-1即可，把j舍弃掉一个并不影响结果。</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.leetcode-cn.com/1599404042-JMvjtL-Picture1.png" alt="Picture1.png"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//利用二分法来解决</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">minArray1</span><span class="params">(<span class="type">int</span>[] numbers)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = numbers.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (i + j) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (numbers[mid] &gt; numbers[j]) &#123;</span><br><span class="line">            <span class="comment">//一定在右排序数组</span></span><br><span class="line">            i = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (numbers[mid] &lt; numbers[j]) &#123;</span><br><span class="line">            <span class="comment">//一定</span></span><br><span class="line">            j = mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//当numbers[mid] = numbers[j]时，只需要j-1即可，把j舍弃掉一个并不影响结果。</span></span><br><span class="line">        <span class="comment">//当出现 nums[m] = nums[j] 时，一定有区间 [i, m] 内所有元素相等 或 区间 [m, j] 内所有元素相等</span></span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//因为此时i=j,即是找到了最下数</span></span><br><span class="line">    <span class="keyword">return</span> numbers[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度O(<strong>log2*N*</strong>)。</p>
<p>空间复杂度O(1)。</p>
<h5 id="剑指-Offer-50-第一次只出现一次的字符"><a href="#剑指-Offer-50-第一次只出现一次的字符" class="headerlink" title="剑指 Offer 50. 第一次只出现一次的字符"></a>剑指 Offer 50. 第一次只出现一次的字符</h5><p>在字符串 s 中找出第一个只出现一次的字符。如果没有，返回一个单空格。 s 只包含小写字母。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;abaccdeff&quot;</span><br><span class="line">输出：&#x27;b&#x27;</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;&quot; </span><br><span class="line">输出：&#x27; &#x27;</span><br></pre></td></tr></table></figure>

<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/di-yi-ge-zhi-chu-xian-yi-ci-de-zi-fu-lcof">https://leetcode-cn.com/problems/di-yi-ge-zhi-chu-xian-yi-ci-de-zi-fu-lcof</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h6 id="知识点-7"><a href="#知识点-7" class="headerlink" title="知识点"></a><strong>知识点</strong></h6><p>考察哈希表的使用。在字符串长度较大、重复字符很多时，“<strong>有序哈希表</strong>” 解法理论上效率更高。</p>
<p><strong>方法一：哈希表</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">char</span> <span class="title function_">firstUniqChar0</span><span class="params">(String s)</span> &#123;</span><br><span class="line"></span><br><span class="line">    HashMap&lt;Character, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">        map.put(s.charAt(i), map.getOrDefault(s.charAt(i),<span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(map.get(s.charAt(i))==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> s.charAt(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>利用boolean类型</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">char</span> <span class="title function_">firstUniqChar</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        HashMap&lt;Character, Boolean&gt; dic = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="type">char</span>[] sc = s.toCharArray();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> c : sc)</span><br><span class="line">            dic.put(c, !dic.containsKey(c));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> c : sc)</span><br><span class="line">            <span class="keyword">if</span>(dic.get(c)) <span class="keyword">return</span> c;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度O(N)：<em>N</em> 为字符串 <code>s</code> 的长度；需遍历 <code>s</code> 两轮，使用 O*(<em>N</em>) ；HashMap 查找操作的复杂度为O*(1) ；</p>
<p>空间复杂度O(1)：由于题目指出 <code>s</code> 只包含小写字母，因此最多有 26 个不同字符，HashMap 存储需占用 O*(26)&#x3D;<em>O</em>(1) 的额外空间。</p>
<p><strong>方法二：有序哈希表</strong></p>
<h6 id="知识点-8"><a href="#知识点-8" class="headerlink" title="知识点"></a><strong>知识点</strong></h6><p>在哈希表的基础上，有序哈希表中的键值对是 <strong>按照插入顺序排序</strong> 的。因此可以<strong>遍历有序哈希表</strong>来找到第一次出现的字符。</p>
<p>即第二次循环采用<strong>遍历有序哈希表</strong>的方式</p>
<p>哈希表是 <strong>去重</strong> 的，即哈希表中键值对数量 ≤ 字符串 <code>s</code> 的长度</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">char</span> <span class="title function_">firstUniqChar</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        Map&lt;Character, Boolean&gt; dic = <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="type">char</span>[] sc = s.toCharArray();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> c : sc)</span><br><span class="line">            dic.put(c, !dic.containsKey(c));</span><br><span class="line">        <span class="comment">//遍历有序哈希表</span></span><br><span class="line">        <span class="keyword">for</span>(Map.Entry&lt;Character, Boolean&gt; d : dic.entrySet())&#123;</span><br><span class="line">           <span class="keyword">if</span>(d.getValue()) <span class="keyword">return</span> d.getKey();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度和空间复杂度和<strong>方法一</strong>相同</p>
<h4 id="Day06"><a href="#Day06" class="headerlink" title="Day06"></a>Day06</h4><h5 id="剑指-Offer-32-从上到下打印二叉树"><a href="#剑指-Offer-32-从上到下打印二叉树" class="headerlink" title="剑指 Offer 32-| 从上到下打印二叉树"></a>剑指 Offer 32-| 从上到下打印二叉树</h5><p>从上到下打印出二叉树的每个节点，同一层的节点按照从左到右的顺序打印。</p>
<p>例如:<br>给定二叉树: [3,9,20,null,null,15,7],</p>
<pre><code>    3
   / \
  9  20
    /  \
   15   7
</code></pre>
<p>返回：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[3,9,20,15,7]</span><br></pre></td></tr></table></figure>

<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-lcof">https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-lcof</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h6 id="知识点-9"><a href="#知识点-9" class="headerlink" title="知识点"></a><strong>知识点</strong></h6><p><strong>广度优先搜索(BFS)<strong>通常借助</strong>队列的先入先出</strong>的特性来实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] levelOrder(TreeNode root) &#123;</span><br><span class="line">       <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>];</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//队列先进先出存放结点</span></span><br><span class="line">       Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">       ArrayList&lt;Integer&gt; arrayList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">       queue.add(root);</span><br><span class="line">       <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">           <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> queue.remove();</span><br><span class="line">           arrayList.add(node.val);</span><br><span class="line">           <span class="comment">//将左右结点放入队列</span></span><br><span class="line">           <span class="keyword">if</span> (node.left != <span class="literal">null</span>) queue.add(node.left);</span><br><span class="line">           <span class="keyword">if</span> (node.right != <span class="literal">null</span>) queue.add(node.right);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[arrayList.size()];</span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; res.length; i++) &#123;</span><br><span class="line">           res[i] = arrayList.get(i);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> res;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度O(N)：<em>N</em> 为二叉树的节点数量，即 BFS 需循环 <em>N</em> 次。</p>
<p>空间复杂度O(N)：最差情况下，即当树为平衡二叉树时，最多有 N*&#x2F;2 个树节点<strong>同时</strong>在 <code>queue</code> 中，使用 O*(<em>N</em>) 大小的额外空间。</p>
<h5 id="剑指-Offer-32-从上到下打印二叉树-1"><a href="#剑指-Offer-32-从上到下打印二叉树-1" class="headerlink" title="剑指 Offer 32-|| 从上到下打印二叉树 ||"></a>剑指 Offer 32-|| 从上到下打印二叉树 ||</h5><p>从上到下按层打印二叉树，同一层的节点按从左到右的顺序打印，每一层打印到一行。</p>
<p>例如:<br>给定二叉树:<code> [3,9,20,null,null,15,7]</code>,</p>
<pre><code>  3
 / \
  9  20
    /  \
   15   7
</code></pre>
<p>返回其层次遍历结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [3],</span><br><span class="line">  [9,20],</span><br><span class="line">  [15,7]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-ii-lcof">https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-ii-lcof</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h6 id="知识点-10"><a href="#知识点-10" class="headerlink" title="知识点"></a><strong>知识点</strong></h6><p><strong>主要重点是加入队列长度为循环条件，即是每层打印。</strong></p>
<p><strong>一次while即是二叉树的一层</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">levelOrder0</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">       Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">       List&lt;List&lt;Integer&gt;&gt; arrayList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">       <span class="keyword">if</span> (root != <span class="literal">null</span>) &#123;</span><br><span class="line">           queue.add(root);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">           <span class="comment">//新建一个临时列表，存储当前的打印结果。</span></span><br><span class="line">           List&lt;Integer&gt; arrayList1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">           <span class="comment">//循环次数为当前层结点数</span></span><br><span class="line">           <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> queue.size(); i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">               <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> queue.remove();</span><br><span class="line">               <span class="comment">//向列表添加结果</span></span><br><span class="line">               arrayList1.add(node.val);</span><br><span class="line">               <span class="keyword">if</span> (node.left != <span class="literal">null</span>) &#123;</span><br><span class="line">                   queue.add(node.left);</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">if</span> (node.right != <span class="literal">null</span>) &#123;</span><br><span class="line">                   queue.add(node.right);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           arrayList.add(arrayList1);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> arrayList;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度O(N)：<em>N</em> 为二叉树的节点数量，即 BFS 需循环 <em>N</em> 次。</p>
<p>空间复杂度O(N)：最差情况下，即当树为平衡二叉树时，最多有 N*&#x2F;2 个树节点<strong>同时</strong>在 <code>queue</code> 中，使用 O*(<em>N</em>) 大小的额外空间。</p>
<h5 id="剑指-Offer-32-从上到下打印二叉树-2"><a href="#剑指-Offer-32-从上到下打印二叉树-2" class="headerlink" title="剑指 Offer 32-||| 从上到下打印二叉树 |||"></a>剑指 Offer 32-||| 从上到下打印二叉树 |||</h5><p>请实现一个函数按照之字形顺序打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右到左的顺序打印，第三行再按照从左到右的顺序打印，其他行以此类推。</p>
<p>例如:<br>给定二叉树: [3,9,20,null,null,15,7],</p>
<pre><code>    3
   / \
  9  20
    /  \
   15   7
</code></pre>
<p>返回其层次遍历结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [3],</span><br><span class="line">  [20,9],</span><br><span class="line">  [15,7]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-iii-lcof">https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-iii-lcof</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h6 id="知识点-11"><a href="#知识点-11" class="headerlink" title="知识点"></a><strong>知识点</strong></h6><p>利用双端队列添加数据</p>
<p><strong>方法一：双端队列</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">levelOrder</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    LinkedList&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">//辅助队列</span></span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; arrayList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (root != <span class="literal">null</span>) &#123;</span><br><span class="line">        queue.add(root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        List&lt;Integer&gt; arrayList1 = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> queue.size(); i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">            <span class="keyword">if</span> (index % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//这里这样写就不用使用双端队列：add(0,node.val);</span></span><br><span class="line">                <span class="comment">//双端队列的写法是addFirst();</span></span><br><span class="line">                <span class="comment">//add(0, node.val);在列表的指定位置插入指定元素（可选操作）。</span></span><br><span class="line">                <span class="comment">//将当前处于该位置的元素（如果有的话）和所有后续元素向右移动（在其索引中加 1）。</span></span><br><span class="line">                <span class="comment">// 因为index是0，所以相当于不断向类别第一个位置插入元素</span></span><br><span class="line">                arrayList1.add(<span class="number">0</span>, node.val);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                arrayList1.add(node.val);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (node.left != <span class="literal">null</span>) &#123;</span><br><span class="line">                queue.add(node.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (node.right != <span class="literal">null</span>) &#123;</span><br><span class="line">                queue.add(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        index++;</span><br><span class="line">        arrayList.add(arrayList1);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arrayList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>方法二：双端队列(奇偶层逻辑分离)</strong></p>
<h6 id="知识点-12"><a href="#知识点-12" class="headerlink" title="知识点"></a><strong>知识点</strong></h6><p><strong>定死奇偶顺序</strong>，想比于方法一消除了冗余判断</p>
<p>循环打印<strong>奇偶层</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">levelOrder</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        Deque&lt;TreeNode&gt; deque = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root != <span class="literal">null</span>) deque.add(root);</span><br><span class="line">        <span class="keyword">while</span>(!deque.isEmpty()) &#123;</span><br><span class="line">            <span class="comment">// 打印奇数层</span></span><br><span class="line">            List&lt;Integer&gt; tmp = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> deque.size(); i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">                <span class="comment">// 从左向右打印</span></span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> deque.removeFirst();</span><br><span class="line">                tmp.add(node.val);</span><br><span class="line">                <span class="comment">// 先左后右加入下层节点</span></span><br><span class="line">                <span class="keyword">if</span>(node.left != <span class="literal">null</span>) deque.addLast(node.left);</span><br><span class="line">                <span class="keyword">if</span>(node.right != <span class="literal">null</span>) deque.addLast(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(tmp);</span><br><span class="line">            <span class="keyword">if</span>(deque.isEmpty()) <span class="keyword">break</span>; <span class="comment">// 若为空则提前跳出</span></span><br><span class="line">            <span class="comment">// 打印偶数层</span></span><br><span class="line">            tmp = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> deque.size(); i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">                <span class="comment">// 从右向左打印</span></span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> deque.removeLast();</span><br><span class="line">                tmp.add(node.val);</span><br><span class="line">                <span class="comment">// 先右后左加入下层节点</span></span><br><span class="line">                <span class="keyword">if</span>(node.right != <span class="literal">null</span>) deque.addFirst(node.right);</span><br><span class="line">                <span class="keyword">if</span>(node.left != <span class="literal">null</span>) deque.addFirst(node.left);</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度等同上一个方法一样</p>
<p><strong>方法三：倒序</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">levelOrder</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span>(root != <span class="literal">null</span>) queue.add(root);</span><br><span class="line">    <span class="keyword">while</span>(!queue.isEmpty()) &#123;</span><br><span class="line">        List&lt;Integer&gt; tmp = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> queue.size(); i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">            tmp.add(node.val);</span><br><span class="line">            <span class="keyword">if</span>(node.left != <span class="literal">null</span>) queue.add(node.left);</span><br><span class="line">            <span class="keyword">if</span>(node.right != <span class="literal">null</span>) queue.add(node.right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(res.size() % <span class="number">2</span> == <span class="number">1</span>) Collections.reverse(tmp);</span><br><span class="line">        res.add(tmp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="Day07"><a href="#Day07" class="headerlink" title="Day07"></a>Day07</h4><h5 id="剑指-Offer-26-树的子结构"><a href="#剑指-Offer-26-树的子结构" class="headerlink" title="剑指 Offer 26. 树的子结构"></a>剑指 Offer 26. 树的子结构</h5><p>输入两棵二叉树A和B，判断B是不是A的子结构。(约定空树不是任意一个树的子结构)</p>
<p>B是A的子结构， 即 A中有出现和B相同的结构和节点值。</p>
<p>例如:<br>给定的树 A:</p>
<pre><code>     3
    / \
  4   5
  / \
 1   2
</code></pre>
<p>给定的树 B：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  4 </span><br><span class="line"> /</span><br><span class="line">1</span><br></pre></td></tr></table></figure>

<p>返回 true，因为 B 与 A 的一个子树拥有相同的结构和节点值。</p>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：A = [1,2,3], B = [3,1]</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure>

<p>示例 2：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：A = [3,4,5,1,2], B = [4,1]</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>

<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/shu-de-zi-jie-gou-lcof">https://leetcode-cn.com/problems/shu-de-zi-jie-gou-lcof</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h6 id="知识点-13"><a href="#知识点-13" class="headerlink" title="知识点"></a>知识点</h6><p><code>recur(A, B) </code>函数：</p>
<p><strong>终止条件</strong>：<br>当节点 B 为空：说明树 B 已匹配完成（越过叶子节点），因此返回true ；<br>当节点 A 为空：说明已经越过树 A 叶子节点，即匹配失败，返回 false ；<br>当节点 A 和 B 的值不同：说明匹配失败，返回 false ；<br><strong>返回值：</strong><br>判断 A 和 B 的左子节点是否相等，即 <code>recur(A.left, B.left)</code> ；<br>判断 A 和 B 的右子节点是否相等，即 <code>recur(A.right, B.right) </code>；<br>isSubStructure(A, B) 函数：</p>
<p><strong>特例处理：</strong> 当 树 A 为空 或 树 B 为空 时，直接返回 false ；<br><strong>返回值：</strong> 若树 B 是树 A 的子结构，则必满足以下三种情况之一，因此用或 <code>||</code> 连接；<br>以 <strong>节点 A 为根节点的子树</strong> 包含树 B ，对应<code> recur(A, B)；</code><br>树 B 是 <strong>树 A 左子树</strong> 的子结构，对应 <code>isSubStructure(A.left, B)；</code><br>树 B 是 <strong>树 A 右子树</strong> 的子结构，对应 <code>isSubStructure(A.right, B)；</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这个方法就是判断B是否为A的子结构</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isSubStructure0</span><span class="params">(TreeNode A, TreeNode B)</span> &#123;</span><br><span class="line">    <span class="comment">//约定空树不是任意一个树的子结构</span></span><br><span class="line">    <span class="keyword">if</span> (A == <span class="literal">null</span> || B == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (recur(A, B)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//递归判断A树所有子树是否包含B树，判断A树根节点的左子结点和右子结点是否包含B树</span></span><br><span class="line">    <span class="keyword">return</span> isSubStructure0(A.left, B) || isSubStructure0(A.right, B);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//该函数的作用是：判断A树根节点值和B树根节点值是否相等，若不等，返回false，</span></span><br><span class="line"><span class="comment">//若相等再递归判断A树的孩子节点和B树的的孩子节点是否对应相等，</span></span><br><span class="line"><span class="comment">//如果对应相等了，就说明A的子结构包含B树，返回true。否者就不包含，返回false</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Boolean <span class="title function_">recur</span><span class="params">(TreeNode A, TreeNode B)</span> &#123;</span><br><span class="line">    <span class="comment">//B为空说明B树已经完成匹配(越过叶子结点)</span></span><br><span class="line">    <span class="keyword">if</span> (B == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (A == <span class="literal">null</span> || A.val != B.val) &#123;</span><br><span class="line">        <span class="comment">//说明A树的根结点和B树的根结点不相等</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//上述条件都不满足时，即是根结点相等，走子结点</span></span><br><span class="line">    <span class="comment">//即看A树的左右子结点是否也跟跟B树的左右结点一样	</span></span><br><span class="line">    <span class="keyword">return</span> recur(A.left, B.left) &amp;&amp; recur(A.right, B.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="剑指-Offer-27-二叉树的镜像"><a href="#剑指-Offer-27-二叉树的镜像" class="headerlink" title="剑指 Offer 27. 二叉树的镜像"></a>剑指 Offer 27. 二叉树的镜像</h5><p>请完成一个函数，输入一个二叉树，该函数输出它的镜像。</p>
<p>例如输入：</p>
<pre><code>       4
    /   \
  2     7
 / \   / \
1   3 6   9
</code></pre>
<p>镜像输出：</p>
<pre><code>     4
    /   \
  7     2
 / \   / \
9   6 3   1
</code></pre>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [4,2,7,1,3,6,9]</span><br><span class="line">输出：[4,7,2,9,6,3,1]</span><br></pre></td></tr></table></figure>

<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/er-cha-shu-de-jing-xiang-lcof">https://leetcode-cn.com/problems/er-cha-shu-de-jing-xiang-lcof</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h6 id="知识点-14"><a href="#知识点-14" class="headerlink" title="知识点"></a>知识点</h6><p><strong>二叉树镜像定义：</strong> 对于二叉树中任意节点 root ，设其左 &#x2F; 右子节点分别为left,right ；则在二叉树的镜像中的对应 root 节点，其左 &#x2F; 右子节点分别为 right,left 。</p>
<ul>
<li>根据二叉树镜像的定义，考虑递归遍历（dfs）二叉树，交换每个节点的左 &#x2F; 右子节点，即可生成二叉树的镜像。</li>
</ul>
<p><strong>方法一：递归自上而下</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">mirrorTree</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//先交换左右子树</span></span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">temp</span> <span class="operator">=</span> root.left;</span><br><span class="line">    root.left = root.right;</span><br><span class="line">    root.right = temp;</span><br><span class="line">    <span class="comment">//遍历进去持续进行交换左右子树</span></span><br><span class="line">    mirrorTree2(root.right);</span><br><span class="line">    mirrorTree2(root.left);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度 O(N) ： 其中 NN 为二叉树的节点数量，建立二叉树镜像需要遍历树的所有节点，占用 O(N) 时间。<br>空间复杂度 O(N) ： 最差情况下（当二叉树退化为链表），递归时系统需使用 O(N) 大小的栈空间。</p>
<p><strong>方法二：自己写的</strong></p>
<h6 id="知识点-15"><a href="#知识点-15" class="headerlink" title="知识点"></a>知识点</h6><p>整体思路是将子树的左节点拼接在新树的右子结点，将右子结点拼接在新树的左子结点。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> TreeNode <span class="title function_">mirrorTree0</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//最终要输出的数</span></span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">res</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(root.val);</span><br><span class="line">    recur(root, res);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">recur</span><span class="params">(TreeNode root, TreeNode res)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//一直将左子结点拼接在新树的右子结点</span></span><br><span class="line">    <span class="keyword">if</span> (root.left != <span class="literal">null</span>) &#123;</span><br><span class="line">        res.right = <span class="keyword">new</span> <span class="title class_">TreeNode</span>(root.left.val);</span><br><span class="line">    &#125;</span><br><span class="line">    recur(root.left, res.right);</span><br><span class="line">    <span class="comment">//一直将右子结点拼接在新树的左子结点</span></span><br><span class="line">    <span class="keyword">if</span> (root.right != <span class="literal">null</span>) &#123;</span><br><span class="line">        res.left = <span class="keyword">new</span> <span class="title class_">TreeNode</span>(root.right.val);</span><br><span class="line">    &#125;</span><br><span class="line">    recur(root.right, res.left);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="剑指-Offer-28-对称的二叉树"><a href="#剑指-Offer-28-对称的二叉树" class="headerlink" title="剑指 Offer 28.对称的二叉树"></a>剑指 Offer 28.对称的二叉树</h5><p>请实现一个函数，用来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。</p>
<p>例如，二叉树 [1,2,2,3,4,4,3] 是对称的。</p>
<pre><code>    1
   / \
  2   2
 / \ / \
3  4 4  3
</code></pre>
<p>但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的:</p>
<pre><code>    1
   / \
  2   2
   \   \
   3    3
</code></pre>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [1,2,2,3,4,4,3]</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>

<p>示例 2：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [1,2,2,null,3,null,3]</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure>

<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/dui-cheng-de-er-cha-shu-lcof">https://leetcode-cn.com/problems/dui-cheng-de-er-cha-shu-lcof</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h6 id="知识点-16"><a href="#知识点-16" class="headerlink" title="知识点"></a>知识点</h6><p>对称二叉树定义： 对于树中 任意两个对称节点 LL 和 RR ，一定有：<br>L.val &#x3D; R.val ：即此两对称节点值相等。<br>L.left.val &#x3D; R.right.val：即 L 的 左子节点 和 R的 右子节点 对称；<br>L.right.val &#x3D; R.left.val ：即 L 的 右子节点 和 R 的 左子节点 对称。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSymmetric</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> recur(root.left, root.right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">recur</span><span class="params">(TreeNode L, TreeNode R)</span> &#123;</span><br><span class="line">    <span class="comment">//当 L 和 R 同时越过叶节点： 此树从顶至底的节点都对称，因此返回 true</span></span><br><span class="line">    <span class="keyword">if</span> (L == <span class="literal">null</span> &amp;&amp; R == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (L == <span class="literal">null</span> || R == <span class="literal">null</span> || L.val != R.val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">//向下递归，以上都不满足，说明满足L==R</span></span><br><span class="line">    <span class="comment">//精髓在于返回值</span></span><br><span class="line">    <span class="keyword">return</span> recur(L.left, R.right) &amp;&amp; recur(L.right, R.left);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(N)</p>
<p>空间复杂度：O(N)</p>
<h4 id="Day08"><a href="#Day08" class="headerlink" title="Day08"></a>Day08</h4><h5 id="剑指-Offer-10-斐波那契数列"><a href="#剑指-Offer-10-斐波那契数列" class="headerlink" title="剑指 Offer 10-|.斐波那契数列"></a>剑指 Offer 10-|.斐波那契数列</h5><p>写一个函数，输入 n ，求斐波那契（Fibonacci）数列的第 n 项（即 F(N)）。斐波那契数列的定义如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">F(0) = 0,   F(1) = 1</span><br><span class="line">F(N) = F(N - 1) + F(N - 2), 其中 N &gt; 1.</span><br></pre></td></tr></table></figure>

<p>斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。</p>
<p>答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</p>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 2</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure>

<p>示例 2：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 5</span><br><span class="line">输出：5</span><br></pre></td></tr></table></figure>

<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/fei-bo-na-qi-shu-lie-lcof">https://leetcode-cn.com/problems/fei-bo-na-qi-shu-lie-lcof</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处</p>
<h6 id="知识点-17"><a href="#知识点-17" class="headerlink" title="知识点"></a>知识点</h6><p>答案需要取模 1e9+7（1000000007）意思是每次计算都要取模1000000007</p>
<p>由于 F*(<em>n</em>) 只和F*(<em>n</em>−1) 与 F*(<em>n</em>−2) 有关，因此可以使用「<strong>滚动数组思想</strong>」把空间复杂度优化成 O*(1)</p>
<p><strong>方法一：递推动态规划</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">fib</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span> || n == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>, b = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> a + b;</span><br><span class="line">        c =c% <span class="number">1000000007</span>;</span><br><span class="line">        <span class="comment">//先得出后一个结果，然后往后交换</span></span><br><span class="line">        a = b;</span><br><span class="line">        b = c;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O*(<em>n</em>)。</li>
<li>空间复杂度：O(1)。</li>
</ul>
<p><strong>方法二：递归动态规划</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] cache = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">110</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">fib</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span> || n == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//递归调用，当n是之前出现过得数，则直接返回数组中存储的数值</span></span><br><span class="line">    <span class="keyword">if</span> (cache[n] != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> cache[n];</span><br><span class="line">    &#125;</span><br><span class="line">    cache[n] = fib(n - <span class="number">1</span>) + fib(n - <span class="number">2</span>);</span><br><span class="line">    <span class="comment">//每次计算都取模，防止超出限制</span></span><br><span class="line">    cache[n] = cache[n] % <span class="number">1000000007</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> cache[n];</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O*(*n)。</li>
<li>空间复杂度：O(n)。</li>
</ul>
<h5 id="剑指-Offer-10-青蛙跳台阶问题"><a href="#剑指-Offer-10-青蛙跳台阶问题" class="headerlink" title="剑指 Offer 10-||.青蛙跳台阶问题"></a>剑指 Offer 10-||.青蛙跳台阶问题</h5><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。</p>
<p>答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</p>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 2</span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure>

<p>示例 2：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 7</span><br><span class="line">输出：21</span><br></pre></td></tr></table></figure>

<p>示例 3：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 0</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure>

<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/qing-wa-tiao-tai-jie-wen-ti-lcof">https://leetcode-cn.com/problems/qing-wa-tiao-tai-jie-wen-ti-lcof</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h6 id="知识点-18"><a href="#知识点-18" class="headerlink" title="知识点"></a>知识点</h6><p>同斐波那契数列的转移方程相同。唯一不同的是起始数字不同</p>
<p>青蛙跳台阶问题： f(0)&#x3D;1 , f(1)&#x3D;1 , f(2)&#x3D;2 ；<br>斐波那契数列问题： f(0)&#x3D;0 , f(1)&#x3D;1 , f(2)&#x3D;1 。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] cache = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">110</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numWays</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cache[n] != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> cache[n];</span><br><span class="line">        &#125;</span><br><span class="line">        cache[n] = numWays0(n - <span class="number">1</span>) + numWays0(n - <span class="number">2</span>);</span><br><span class="line">        cache[n] = cache[n] % <span class="number">1000000007</span>;</span><br><span class="line">        <span class="keyword">return</span> cache[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>时间复杂度：O*(*n)。</p>
</li>
<li><p>空间复杂度：O(n)。</p>
</li>
</ul>
<h5 id="剑指-Offer-63-股票的最大利润"><a href="#剑指-Offer-63-股票的最大利润" class="headerlink" title="剑指 Offer 63.股票的最大利润"></a>剑指 Offer 63.股票的最大利润</h5><p>假设把某股票的价格按照时间先后顺序存储在数组中，请问买卖该股票一次可能获得的最大利润是多少？</p>
<p>示例 1:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: [7,1,5,3,6,4]</span><br><span class="line">输出: 5</span><br><span class="line">解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。</span><br><span class="line">     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。</span><br></pre></td></tr></table></figure>

<p>示例 2:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [7,6,4,3,1]</span><br><span class="line">输出: 0</span><br><span class="line">解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。</span><br></pre></td></tr></table></figure>

<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/gu-piao-de-zui-da-li-run-lcof">https://leetcode-cn.com/problems/gu-piao-de-zui-da-li-run-lcof</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h6 id="知识点-19"><a href="#知识点-19" class="headerlink" title="知识点"></a>知识点</h6><p><strong>状态定义</strong>： 设动态规划列表 dp ，dp[i] 代表以 prices[i] 为结尾的子数组的最大利润（<strong>以下简称为 前 i 日的最大利润</strong> ）。<br><strong>转移方程</strong>： 由于题目限定 “<strong>买卖该股票一次</strong>” ，因此<strong>前 i 日最大利润 dp[i]</strong> 等于<strong>前 i−1 日最大利润 dp[i−1]</strong> 和<strong>第 i 日卖出的最大利润</strong>中的最大值。</p>
<p><strong>前i日最大利润&#x3D;max(前(i−1)日最大利润,第i日价格−前i日最低价格)</strong><br><strong>dp[i]&#x3D;max(dp[i−1],prices[i]−min(prices[0:i]))</strong></p>
<p><strong>初始状态</strong>：dp[0]&#x3D;0 ，即首日利润为 0 ；<br><strong>返回值</strong>： dp[n−1] ，其中 n 为 dp 列表长度。</p>
<p><strong>用一个变量代替dp数组</strong>降低空间复杂度</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (prices.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//cost是i天前的最低价格</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">mincost</span> <span class="operator">=</span> prices[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">profit</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; prices.length; i++) &#123;</span><br><span class="line">            mincost = Math.min(mincost, prices[i]);</span><br><span class="line">            <span class="comment">//第i最大利润为i天前的最大利润和i天当天的利润最大值</span></span><br><span class="line">            profit = Math.max(profit, prices[i] - mincost);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> profit;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O*(*n)。</li>
<li>空间复杂度：O(n)。</li>
</ul>
<p><strong>用到数组的动态规划</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (prices.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//cost是i天前的最低价格</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">mincost</span> <span class="operator">=</span> prices[<span class="number">0</span>];</span><br><span class="line">    <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[prices.length];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; prices.length; i++) &#123;</span><br><span class="line">        mincost = Math.min(mincost, prices[i]);</span><br><span class="line">        <span class="comment">//第i天最大利润为i天前的最大利润和i天当天的利润最大值</span></span><br><span class="line">        dp[i] = Math.max(dp[i - <span class="number">1</span>], prices[i] - mincost);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[prices.length - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="Day09"><a href="#Day09" class="headerlink" title="Day09"></a>Day09</h4><h5 id="剑指Offer-42-连续子数组的最大和"><a href="#剑指Offer-42-连续子数组的最大和" class="headerlink" title="剑指Offer 42.连续子数组的最大和"></a>剑指Offer 42.连续子数组的最大和</h5><p>输入一个整型数组，数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。</p>
<p>要求时间复杂度为O(n)。</p>
<p>示例1:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [-2,1,-3,4,-1,2,1,-5,4]</span><br><span class="line">输出: 6</span><br><span class="line">解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。</span><br></pre></td></tr></table></figure>

<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof">https://leetcode-cn.com/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h6 id="知识点-20"><a href="#知识点-20" class="headerlink" title="知识点"></a>知识点</h6><p>动态规划求解，<strong>原数组i下标数组下</strong>存放的是<strong>以i为结尾的</strong>连续数组最大和</p>
<p>转移方程：若<strong>nums[i-1]&lt;&#x3D;0</strong>，说明<strong>nums[i-1]对nums[i]产生负影响</strong>，即<strong>nums[i-1]+nums[i]还不如nums[i]本身大</strong></p>
<p>又因为题目<strong>要求连续数组</strong>，此时可以<strong>直接舍弃前面的数</strong>，重新开始计数。<strong>nums[i] 值不变就是表明重新开始</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxSubArray</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">     <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> nums[<span class="number">0</span>];</span><br><span class="line">     <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">          <span class="keyword">if</span> (nums[i - <span class="number">1</span>] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">              nums[i] = nums[i - <span class="number">1</span>] + nums[i];</span><br><span class="line">          &#125;</span><br><span class="line">          max = Math.max(nums[i],max);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度 O(N) ： 线性遍历数组 nums 即可获得结果，使用 O(N) 时间。<br>空间复杂度 O(1) ： 使用常数大小的额外空间。</p>
<p><strong>前缀和</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxSubArray</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">preSum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">minSum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxSubSum</span> <span class="operator">=</span> Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">            <span class="comment">//前缀合，不断加上当前num值</span></span><br><span class="line">            preSum += num;</span><br><span class="line">            <span class="comment">//前缀和减去最小的值，再和之前获得的最大值比较，取最大值</span></span><br><span class="line">            maxSubSum = Math.max(maxSubSum, preSum - minSum);</span><br><span class="line">            <span class="comment">//得到最小值</span></span><br><span class="line">            minSum = Math.min(minSum, preSum);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxSubSum;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h5 id="剑指-Offer-47-礼物的最大价值"><a href="#剑指-Offer-47-礼物的最大价值" class="headerlink" title="剑指 Offer 47.礼物的最大价值"></a>剑指 Offer 47.礼物的最大价值</h5><p>在一个 <strong>m*n 的棋盘</strong>的每一格都放有一个礼物，每个礼物都有一定的价值（价值大于 0）。你可以从棋盘的左上角开始拿格子里的礼物，并<strong>每次向右或者向下移动一格</strong>、<strong>直到到达棋盘的右下角</strong>。给定一个棋盘及其上面的礼物的价值，请计算你<strong>最多能拿到多少价值的礼物</strong>？</p>
<p>示例 1:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入: </span><br><span class="line">[</span><br><span class="line">  [1,3,1],</span><br><span class="line">  [1,5,1],</span><br><span class="line">  [4,2,1]</span><br><span class="line">]</span><br><span class="line">输出: 12</span><br><span class="line">解释: 路径 1→3→5→2→1 可以拿到最多价值的礼物</span><br></pre></td></tr></table></figure>

<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/li-wu-de-zui-da-jie-zhi-lcof">https://leetcode-cn.com/problems/li-wu-de-zui-da-jie-zhi-lcof</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h6 id="知识点-21"><a href="#知识点-21" class="headerlink" title="知识点"></a>知识点</h6><p>根据题目说明，易得某单元格只可能从上边单元格或左边单元格到达。</p>
<p>设 <strong>f(i, j) 为从棋盘左上角走至单元格 (i ,j) 的礼物最大累计价值</strong>，易得到以下递推关系：<strong>f(i,j) 等于 f(i,j-1) 和 f(i-1,j)中的较大值加上当前单元格礼物价值 grid(i,j)</strong> 。</p>
<p>因此用动态规划来做：<strong>转移方程</strong> <em>f</em>(<em>i</em>,<em>j</em>)&#x3D;max[<em>f</em>(<em>i</em>,<em>j</em>−1),<em>f</em>(<em>i</em>−1,<em>j</em>)]+grid(i,j)</p>
<p>通过增加一行和一列的空间来简化代码并<strong>解决边界问题</strong>，因为i-1和j-1在i和j都为0时越界。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxValue</span><span class="params">(<span class="type">int</span>[][] grid)</span> &#123;</span><br><span class="line">    <span class="comment">//设置多一个0值</span></span><br><span class="line">    <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[grid.length + <span class="number">1</span>][grid[<span class="number">0</span>].length + <span class="number">1</span>];</span><br><span class="line">    <span class="comment">//设置初始值0</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; dp[<span class="number">0</span>].length; i++) &#123;</span><br><span class="line">        dp[<span class="number">0</span>][i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; dp.length; i++) &#123;</span><br><span class="line">        dp[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; dp.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; dp[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">            dp[i][j] = Math.max(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]) + grid[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[dp.length - <span class="number">1</span>][dp[<span class="number">0</span>].length - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="Daya10"><a href="#Daya10" class="headerlink" title="Daya10"></a>Daya10</h4><h5 id="剑指-Offer-46-把数字翻译成字符串"><a href="#剑指-Offer-46-把数字翻译成字符串" class="headerlink" title="剑指 Offer 46. 把数字翻译成字符串"></a>剑指 Offer 46. 把数字翻译成字符串</h5><p>给定一个数字，我们按照如下规则把它翻译为字符串：0 翻译成 “a” ，1 翻译成 “b”，……，11 翻译成 “l”，……，25 翻译成 “z”。一个数字可能有多个翻译。请编程实现一个函数，用来计算一个数字有多少种不同的翻译方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">输入: 12258</span><br><span class="line">输出: 5</span><br><span class="line">解释: 12258有5种不同的翻译，分别是&quot;bccfi&quot;, &quot;bwfi&quot;, &quot;bczi&quot;, &quot;mcfi&quot;和&quot;mzi&quot;</span><br></pre></td></tr></table></figure>

<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/ba-shu-zi-fan-yi-cheng-zi-fu-chuan-lcof">https://leetcode-cn.com/problems/ba-shu-zi-fan-yi-cheng-zi-fu-chuan-lcof</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h6 id="知识点-22"><a href="#知识点-22" class="headerlink" title="知识点"></a>知识点</h6><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\14591\AppData\Roaming\Typora\typora-user-images\image-20220402232251818.png" alt="image-20220402232251818"></p>
<p><strong>方法一：字符串遍历</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">translateNum1</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> String.valueOf(num);</span><br><span class="line">    <span class="comment">//b是第0位，a是第一位</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">1</span>, a = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">        <span class="comment">//此时不包括右边的i</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">temp</span> <span class="operator">=</span> s.substring(i - <span class="number">2</span>, i);</span><br><span class="line">        <span class="comment">//a</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> temp.compareTo(<span class="string">&quot;10&quot;</span>) &gt;= <span class="number">0</span> &amp;&amp; temp.compareTo(<span class="string">&quot;25&quot;</span>) &lt;= <span class="number">0</span> ? a + b : a;</span><br><span class="line">        <span class="comment">//循环往后</span></span><br><span class="line">        b = a;</span><br><span class="line">        a = c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回最后的值</span></span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此题的动态规划计算是 对称的 ，即 从左向右 遍历（从第 dp[2] 计算至 dp[n] ）和 从右向左 遍历（从第 dp[n - 2]dp[n−2] 计算至 dp[0]）所得方案数一致。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">translateNum2</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> String.valueOf(num);</span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>, b = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> s.length() - <span class="number">2</span>; i &gt; -<span class="number">1</span>; i--) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">tmp</span> <span class="operator">=</span> s.substring(i, i + <span class="number">2</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> tmp.compareTo(<span class="string">&quot;10&quot;</span>) &gt;= <span class="number">0</span> &amp;&amp; tmp.compareTo(<span class="string">&quot;25&quot;</span>) &lt;= <span class="number">0</span> ? a + b : a;</span><br><span class="line">        b = a;</span><br><span class="line">        a = c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\14591\AppData\Roaming\Typora\typora-user-images\image-20220402234006278.png" alt="image-20220402234006278"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">translateNum3</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>, b = <span class="number">1</span>, x;</span><br><span class="line">    <span class="comment">//先的得到个位数</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> num % <span class="number">10</span>;</span><br><span class="line">    <span class="comment">//当num还有数时</span></span><br><span class="line">    <span class="keyword">while</span> (num != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//进入循环，减去一个数</span></span><br><span class="line">        num /= <span class="number">10</span>;</span><br><span class="line">        <span class="comment">//得到y往前一个数</span></span><br><span class="line">        x = num % <span class="number">10</span>;</span><br><span class="line">        <span class="comment">//将x，y合并变为十位数，用于判断</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> x * <span class="number">10</span> + y;</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> (temp &gt;= <span class="number">10</span> &amp;&amp; temp &lt;= <span class="number">25</span>) ? a + b : a;</span><br><span class="line">        b = a;</span><br><span class="line">        a = c;</span><br><span class="line">        <span class="comment">//往前走</span></span><br><span class="line">        y = x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="剑指-Offer-48-最长不含重复字符的子字符串"><a href="#剑指-Offer-48-最长不含重复字符的子字符串" class="headerlink" title="剑指 Offer 48. 最长不含重复字符的子字符串"></a>剑指 Offer 48. 最长不含重复字符的子字符串</h5><p>请从字符串中找出一个最长的不包含重复字符的子字符串，计算该最长子字符串的长度。</p>
<p>示例 1:</p>
<p>输入: “abcabcbb”<br>输出: 3<br>解释: 因为无重复字符的最长子串是 “abc”，所以其长度为 3。<br>示例 2:</p>
<p>输入: “bbbbb”<br>输出: 1<br>解释: 因为无重复字符的最长子串是 “b”，所以其长度为 1。<br>示例 3:</p>
<p>输入: “pwwkew”<br>输出: 3<br>解释: 因为无重复字符的最长子串是 “wke”，所以其长度为 3。<br>     请注意，你的答案必须是 子串 的长度，”pwke” 是一个子序列，不是子串。</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/zui-chang-bu-han-zhong-fu-zi-fu-de-zi-zi-fu-chuan-lcof">https://leetcode-cn.com/problems/zui-chang-bu-han-zhong-fu-zi-fu-de-zi-zi-fu-chuan-lcof</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<p><strong>知识点</strong></p>
<p>哈希表用来记录<strong>元素和其索引下标</strong></p>
<p>左指针 <code>start</code>  更新左指针根据<strong>上轮左指针<code>start</code>和当前重复元素的下标的最大值</strong>，保证了区间 [ start+1, map.get[temp] ]内无重复元素</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">start = Math.max(start,map.get(tmp));</span><br></pre></td></tr></table></figure>

<p>最终结果<code>max</code>：取上一轮max和滑动窗口<code>i-start</code>中的最大值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Math.max(max,i-start);</span><br></pre></td></tr></table></figure>

<p>需要注意的是<strong>左指针必须是从-1开始</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lengthOfLongestSubstring</span><span class="params">(String s)</span> &#123;</span><br><span class="line">       <span class="comment">//if(s==null) return 0;这句话可以不加，s.length()长度为0时，不进入下面的循环，会直接返回max=0;</span></span><br><span class="line">       <span class="comment">//划定当前窗口的坐标为(start,i],左开右闭,所以start的初始值为-1，而非0。</span></span><br><span class="line">       <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>,start =-<span class="number">1</span>;</span><br><span class="line">       <span class="comment">//使用哈希表map统计各字符最后一次出现的索引位置</span></span><br><span class="line">       HashMap&lt;Character,Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.length();i++)&#123;</span><br><span class="line">           <span class="type">char</span> <span class="variable">tmp</span> <span class="operator">=</span> s.charAt(i);</span><br><span class="line"></span><br><span class="line">           <span class="comment">//当字符在map中已经存储时，需要判断其索引值index和当前窗口start的大小以确定是否需要对start进行更新:</span></span><br><span class="line">           <span class="comment">//当index&gt;start时，start更新为当前的index,否则保持不变。</span></span><br><span class="line">           <span class="comment">//注意若index作为新的start，计算当前滑动空间的长度时也是不计入的，左开右闭，右侧s[i]会计入，这样也是防止字符的重复计入。</span></span><br><span class="line">       </span><br><span class="line">           <span class="keyword">if</span>(map.containsKey(tmp)) start = Math.max(start,map.get(tmp));</span><br><span class="line"></span><br><span class="line">           <span class="comment">//如果map中不含tmp，此处是在map中新增一个键值对，否则是对原有的键值对进行更新</span></span><br><span class="line">           map.put(tmp,i);</span><br><span class="line"></span><br><span class="line">           <span class="comment">//i-start,为当前滑动空间(start,i]的长度，若其大于max，则需要进行更新。</span></span><br><span class="line">           <span class="comment">//如果是上面没有进入if条件，是第一次出现的元素，i-start相当于增加了1</span></span><br><span class="line">           max = Math.max(max,i-start);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> max;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>复杂度分析：<br>时间复杂度 O(N)： 其中 N 为字符串长度，动态规划需遍历计算 dp列表。<br>空间复杂度 O(1)： 字符的 ASCII 码范围为 0 ~ 127 ，哈希表 dic 最多使用 O(128) &#x3D; O(1)大小的额外空间。</p>
<h4 id="Day11"><a href="#Day11" class="headerlink" title="Day11"></a>Day11</h4><h5 id="剑指-Offer-18-删除链表的节点"><a href="#剑指-Offer-18-删除链表的节点" class="headerlink" title="剑指 Offer 18. 删除链表的节点"></a>剑指 Offer 18. 删除链表的节点</h5><p>给定单向链表的头指针和一个要删除的节点的值，定义一个函数删除该节点。</p>
<p>返回删除后的链表的头节点。</p>
<p>注意：此题对比原题有改动</p>
<p>示例 1:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: head = [4,5,1,9], val = 5</span><br><span class="line">输出: [4,1,9]</span><br><span class="line">解释: 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 1 -&gt; 9.</span><br></pre></td></tr></table></figure>

<p>示例 2:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: head = [4,5,1,9], val = 1</span><br><span class="line">输出: [4,5,9]</span><br><span class="line">解释: 给定你链表中值为 1 的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 5 -&gt; 9.</span><br></pre></td></tr></table></figure>

<h6 id="知识点-23"><a href="#知识点-23" class="headerlink" title="知识点"></a>知识点</h6><p>关键在与要设置一个前置指针用于删除结点。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title function_">deleteNode</span><span class="params">(ListNode head, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (head.val == val) &#123;</span><br><span class="line">            <span class="keyword">return</span> head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head.next;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur.val == val) &#123;</span><br><span class="line">                pre.next = cur.next;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">            pre = pre.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度 O(N)： N为链表长度，删除操作平均循环N&#x2F;2次，最差N次。<br>空间复杂度 O(1)： 占用常数个空间。</p>
<h5 id="剑指-Offer-22-链表中倒数第k个节点"><a href="#剑指-Offer-22-链表中倒数第k个节点" class="headerlink" title="剑指 Offer 22. 链表中倒数第k个节点"></a>剑指 Offer 22. 链表中倒数第k个节点</h5><p>输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。</p>
<p>例如，一个链表有 6 个节点，从头节点开始，它们的值依次是 1、2、3、4、5、6。这个链表的倒数第 3 个节点是值为 4 的节点。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 k = 2.</span><br><span class="line"></span><br><span class="line">返回链表 4-&gt;5.</span><br></pre></td></tr></table></figure>

<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof">https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h6 id="知识点-24"><a href="#知识点-24" class="headerlink" title="知识点"></a>知识点</h6><p>使用双指针。先初始化双指针都指向head。<strong>构建一个双指针的距离为k。然后共同移动双指针每轮都走一步</strong>。直到前指针走到链表尾结点时跳出（跳出后， <code>latter</code> 与尾节点距离为 k-1，即 <code>latter</code> 指向倒数第 k 个节点）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">getKthFromEnd</span><span class="params">(ListNode head, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="comment">//former为前指针，latter为后一个。</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">former</span> <span class="operator">=</span> head, latter = head;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">            <span class="comment">//判空</span></span><br><span class="line">            <span class="keyword">if</span>(former == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            former = former.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//不为空时共同向后移动</span></span><br><span class="line">        <span class="keyword">while</span>(former != <span class="literal">null</span>) &#123;</span><br><span class="line">            former = former.next;</span><br><span class="line">            latter = latter.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> latter;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>普通方法：先计算长度然后得到目标结点</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">getKthFromEnd</span><span class="params">(ListNode head, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> getLength(head);</span><br><span class="line">    <span class="keyword">if</span> (k &lt; <span class="number">0</span> || k - size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size - k; i++) &#123;</span><br><span class="line">        cur = cur.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> cur;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getLength</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">null</span>) &#123; <span class="comment">//空链表</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 定义一个辅助变量</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="literal">null</span>) &#123;</span><br><span class="line">        length++;</span><br><span class="line">        cur = cur.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="Day12"><a href="#Day12" class="headerlink" title="Day12"></a>Day12</h4><h5 id="剑指-Offer-25-合并两个排序的链表"><a href="#剑指-Offer-25-合并两个排序的链表" class="headerlink" title="剑指 Offer 25. 合并两个排序的链表"></a>剑指 Offer 25. 合并两个排序的链表</h5><p>输入两个递增排序的链表，合并这两个链表并使新链表中的节点仍然是递增排序的。</p>
<p>示例1：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">4</span>, <span class="number">1</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span></span><br><span class="line">输出：<span class="number">1</span>-&gt;<span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span>-&gt;<span class="number">4</span></span><br></pre></td></tr></table></figure>

<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/he-bing-liang-ge-pai-xu-de-lian-biao-lcof">https://leetcode-cn.com/problems/he-bing-liang-ge-pai-xu-de-lian-biao-lcof</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h6 id="知识点-25"><a href="#知识点-25" class="headerlink" title="知识点"></a>知识点</h6><p>因为两个链表是递增的，所以使用双指针L1和L2来遍历两个链表，根据两个指针所指向结点的大小关系来确定结点添加顺序</p>
<p><strong>算法流程</strong></p>
<p>首先初始化伪头节点，循环合并：当其中一个指针遍历到最后为空时，跳出循环。判断两个指针指向的节点值，将小的值添加到伪头节点后。当其中一个指针指向空时，则判断是哪个指针指向不为空，将该指针添加到结果链表后。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title function_">mergeTwoLists1</span><span class="params">(ListNode l1, ListNode l2)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建伪头节点</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">res</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">head</span> <span class="operator">=</span> res;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (l1 != <span class="literal">null</span> &amp;&amp; l2 != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (l1.val &lt;= l2.val) &#123;</span><br><span class="line">            res.next = l1;</span><br><span class="line">            l1 = l1.next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            res.next = l2;</span><br><span class="line">            l2 = l2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        res = res.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (l1 != <span class="literal">null</span>) &#123;</span><br><span class="line">        res.next = l1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (l2 != <span class="literal">null</span>) &#123;</span><br><span class="line">        res.next = l2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度 O(M+N) ： M, N分别为链表 L1, L2的长度，<strong>合并操作需遍历两链表。</strong><br>空间复杂度 O(1) ： 节点引用 dum, cur 使用常数大小的额外空间。</p>
<h5 id="剑指-Offer-52-两个链表的第一个公共节点"><a href="#剑指-Offer-52-两个链表的第一个公共节点" class="headerlink" title="剑指 Offer 52. 两个链表的第一个公共节点"></a>剑指 Offer 52. 两个链表的第一个公共节点</h5><p>输入两个链表，找出它们的第一个公共节点。</p>
<p>如下面的两个链表：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png" alt="img"></p>
<p>在节点 c1 开始相交。</p>
<p>示例 1：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_example_1.png" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3</span><br><span class="line">输出：Reference of the node with value = 8</span><br><span class="line">输入解释：相交节点的值为 8 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。</span><br></pre></td></tr></table></figure>


<p>示例 2：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_example_2.png" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：intersectVal = 2, listA = [0,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1</span><br><span class="line">输出：Reference of the node with value = 2</span><br><span class="line">输入解释：相交节点的值为 2 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [0,9,1,2,4]，链表 B 为 [3,2,4]。在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。</span><br></pre></td></tr></table></figure>


<p>示例 3：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_example_3.png" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2</span><br><span class="line">输出：null</span><br><span class="line">输入解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。</span><br><span class="line">解释：这两个链表不相交，因此返回 null。</span><br></pre></td></tr></table></figure>


<p>注意：</p>
<p>如果两个链表没有交点，返回 null.<br>在返回结果后，两个链表仍须保持原有的结构。<br>可假定整个链表结构中没有循环。<br><strong>程序尽量满足 O(n) 时间复杂度，且仅用 O(1) 内存。</strong><br>本题与主站 160 题相同：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists/">https://leetcode-cn.com/problems/intersection-of-two-linked-lists/</a></p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian-lcof">https://leetcode-cn.com/problems/liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian-lcof</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h6 id="知识点-26"><a href="#知识点-26" class="headerlink" title="知识点"></a>知识点</h6><p>我们使用两个指针 node1，node2 分别指向两个链表 headA，headB 的头结点，然后同时分别逐结点遍历，当 node1 到达链表 headA 的末尾时，重新定位到链表 headB 的头结点；当 node2 到达链表 headB 的末尾时，重新定位到链表 headA 的头结点。</p>
<p>这样，当它们相遇时，所指向的结点就是第一个公共结点。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title function_">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> &#123;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">curA</span> <span class="operator">=</span> headA, curB = headB;</span><br><span class="line">    <span class="keyword">while</span> (curA != curB) &#123;</span><br><span class="line">        <span class="keyword">if</span> (curA != <span class="literal">null</span>) &#123;</span><br><span class="line">            curA = curA.next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//遍历完再去遍历B链表</span></span><br><span class="line">            curA = headB;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (curB != <span class="literal">null</span>) &#123;</span><br><span class="line">            curB = curB.next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//遍历完再去遍历A链表</span></span><br><span class="line">            curB = headA;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//循环结束，相遇直接返回A指针</span></span><br><span class="line">    <span class="keyword">return</span> curA;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>- 时间复杂度：O(M+N)。M和N为A,B链表的长度。<br>- 空间复杂度：O(1)。</p>
<h4 id="Day13"><a href="#Day13" class="headerlink" title="Day13"></a>Day13</h4><h5 id="剑指-Offer-21-调整数组顺序使奇数位于偶数前面"><a href="#剑指-Offer-21-调整数组顺序使奇数位于偶数前面" class="headerlink" title="剑指 Offer 21. 调整数组顺序使奇数位于偶数前面"></a>剑指 Offer 21. 调整数组顺序使奇数位于偶数前面</h5><p>输入一个整数数组，实现一个函数来调整该数组中数字的顺序，<strong>使得所有奇数在数组的前半部分，所有偶数在数组的后半部分。</strong></p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,2,3,4]</span><br><span class="line">输出：[1,3,2,4] </span><br><span class="line">注：[3,1,2,4] 也是正确的答案之一。</span><br></pre></td></tr></table></figure>

<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/diao-zheng-shu-zu-shun-xu-shi-qi-shu-wei-yu-ou-shu-qian-mian-lcof">https://leetcode-cn.com/problems/diao-zheng-shu-zu-shun-xu-shi-qi-shu-wei-yu-ou-shu-qian-mian-lcof</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h6 id="知识点-27"><a href="#知识点-27" class="headerlink" title="知识点"></a>知识点</h6><p>双指针，在数组的头和尾分别定义一个指针,指针left从左往右寻找偶数，指针从右往左寻找奇数，将找到的偶数和奇数交换位置。</p>
<p>最终保证指针left左边都是奇数，指针right右边都是偶数。</p>
<p>指针left遇到奇数则执行left++跳过，直到找到偶数</p>
<p>指针right遇到偶数则执行right++跳过，直到找到奇数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] exchange0(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//两个指针相遇的时候跳出</span></span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="comment">//找到偶数,还有加上left&lt;right判断是因为肯提前遇到left==right</span></span><br><span class="line">        <span class="comment">//类似于[1,3,5]这个例子</span></span><br><span class="line">        <span class="comment">//可以直接使用nums[left] &amp; 1，因为nums[left]等价与nums[left] % 2 != 0</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[left] % <span class="number">2</span> != <span class="number">0</span>) &#123;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//遇到偶数则跳过</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[right] % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//交换</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> nums[left];</span><br><span class="line">        nums[left] = nums[right];</span><br><span class="line">        nums[right] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>快慢指针</p>
<ul>
<li><p>定义快慢双指针 fast 和 low ，fast 在前， low 在后 .</p>
</li>
<li><p>fast的作用是向前搜索奇数位置，low 的作用是指向下一个奇数应当存放的位置</p>
</li>
<li><p>fast 向前移动，当它搜索到奇数时，将它和 nums[low] 交换，此时 low向前移动一个位置 .</p>
</li>
<li><p>重复上述操作，直到 fast指向数组末尾</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] exchange(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">fast</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">slow</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (fast != nums.length - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">//遇到奇数进行交换</span></span><br><span class="line">        <span class="keyword">if</span> ((nums[fast] &amp; <span class="number">1</span>) == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="comment">//交换</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> nums[fast];</span><br><span class="line">            nums[fast] = nums[slow];</span><br><span class="line">            nums[slow] = temp;</span><br><span class="line">            <span class="comment">//向右走</span></span><br><span class="line">            slow++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//向右走</span></span><br><span class="line">        fast++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度为O(N)</p>
<p>空间复杂度为O(1)</p>
<h5 id="剑指-Offer-57-和为s的两个数字"><a href="#剑指-Offer-57-和为s的两个数字" class="headerlink" title="剑指 Offer 57. 和为s的两个数字"></a>剑指 Offer 57. 和为s的两个数字</h5><p>输入一个递增排序的数组和一个数字s，在数组中查找两个数，使得它们的和正好是s。如果有多对数字的和等于s，则输出任意一对即可。</p>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [2,7,11,15], target = 9</span><br><span class="line">输出：[2,7] 或者 [7,2]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>示例 2：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [10,26,30,31,47,60], target = 40</span><br><span class="line">输出：[10,30] 或者 [30,10]</span><br></pre></td></tr></table></figure>

<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/he-wei-sde-liang-ge-shu-zi-lcof">https://leetcode-cn.com/problems/he-wei-sde-liang-ge-shu-zi-lcof</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h6 id="知识点-28"><a href="#知识点-28" class="headerlink" title="知识点"></a>知识点</h6><p>使用双指针完成分别在数组的头尾定义一个指针。因为是有序递增数组。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] twoSum1(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">s</span> <span class="operator">=</span> nums[left] + nums[right];</span><br><span class="line">        <span class="keyword">if</span> (s &lt; target) &#123;</span><br><span class="line">            left++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s &gt; target) &#123;</span><br><span class="line">            right--;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;nums[left], nums[right]&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度O(N):遍历数组的长度</p>
<p>空间复杂度O(1)。</p>
<h5 id="剑指-Offer-58-I-翻转单词顺序"><a href="#剑指-Offer-58-I-翻转单词顺序" class="headerlink" title="剑指 Offer 58 - I. 翻转单词顺序"></a>剑指 Offer 58 - I. 翻转单词顺序</h5><p>输入一个英文句子，翻转句子中单词的顺序，但单词内字符的顺序不变。为简单起见，标点符号和普通字母一样处理。例如输入字符串”I am a student. “，则输出”student. a am I”。</p>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;the sky is blue&quot;</span><br><span class="line">输出: &quot;blue is sky the&quot;</span><br></pre></td></tr></table></figure>

<p>示例 2：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;  hello world!  &quot;</span><br><span class="line">输出: &quot;world! hello&quot;</span><br><span class="line">解释: 输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。</span><br></pre></td></tr></table></figure>

<p>示例 3：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;a good   example&quot;</span><br><span class="line">输出: &quot;example good a&quot;</span><br><span class="line">解释: 如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。</span><br></pre></td></tr></table></figure>

<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/fan-zhuan-dan-ci-shun-xu-lcof">https://leetcode-cn.com/problems/fan-zhuan-dan-ci-shun-xu-lcof</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h6 id="知识点-29"><a href="#知识点-29" class="headerlink" title="知识点"></a>知识点</h6><p>双指针实现</p>
<ul>
<li>倒序遍历字符串 ss ，记录单词左右索引边界 ii , jj ；</li>
<li>每确定一个单词的边界，则将其添加至单词列表 resres ；</li>
<li>最终，将单词列表拼接为字符串，并返回即可。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">reverseWords</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        s = s.trim(); <span class="comment">// 删除首尾空格</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> s.length() - <span class="number">1</span>, i = j;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">res</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">while</span>(i &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span>(i &gt;= <span class="number">0</span> &amp;&amp; s.charAt(i) != <span class="string">&#x27; &#x27;</span>) i--; <span class="comment">// 搜索首个空格</span></span><br><span class="line">            res.append(s.substring(i + <span class="number">1</span>, j + <span class="number">1</span>) + <span class="string">&quot; &quot;</span>); <span class="comment">// 添加单词</span></span><br><span class="line">            <span class="keyword">while</span>(i &gt;= <span class="number">0</span> &amp;&amp; s.charAt(i) == <span class="string">&#x27; &#x27;</span>) i--; <span class="comment">// 跳过单词间空格</span></span><br><span class="line">            j = i; <span class="comment">// j 指向下个单词的尾字符</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res.toString().trim(); <span class="comment">// 转化为字符串并返回</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用库函数实现，先除去单词列表前后空格并分割字符。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">reverseWords0</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="comment">//会将空格也删除并分割字符，只剩下字符，\\s+正则表达式</span></span><br><span class="line">    String[] res = s.trim().split(<span class="string">&quot;\\s+&quot;</span>);</span><br><span class="line">    <span class="type">StringBuffer</span> <span class="variable">stringBuffer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//倒序遍历单词列表</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> res.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="comment">//拼接单词</span></span><br><span class="line">        stringBuffer.append(res[i]).append(<span class="string">&quot; &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> stringBuffer.toString().trim();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度O(N)</p>
<p>空间复杂度O(N):使用了StringBuffer占用线性大小空间。</p>
<h4 id="Day14"><a href="#Day14" class="headerlink" title="Day14"></a>Day14</h4><h5 id="剑指-Offer-12-矩阵中的路径"><a href="#剑指-Offer-12-矩阵中的路径" class="headerlink" title="剑指 Offer 12. 矩阵中的路径"></a>剑指 Offer 12. 矩阵中的路径</h5><p>给定一个 <strong>m x n 二维字符网格 board 和一个字符串单词 word</strong> 。如果 word 存在于网格中，返回 true ；否则，返回 false 。</p>
<p>单词必须按照字母顺序，通过相邻的单元格内的字母构成，<strong>其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。</strong></p>
<p>例如，在下面的 3×4 的矩阵中包含单词 “ABCCED”（单词中的字母已标出）。</p>
<p> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://assets.leetcode.com/uploads/2020/11/04/word2.jpg" alt="img"></p>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：board = [[&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;E&quot;],[&quot;S&quot;,&quot;F&quot;,&quot;C&quot;,&quot;S&quot;],[&quot;A&quot;,&quot;D&quot;,&quot;E&quot;,&quot;E&quot;]], word = &quot;ABCCED&quot;</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>

<p>示例 2：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：board = [[&quot;a&quot;,&quot;b&quot;],[&quot;c&quot;,&quot;d&quot;]], word = &quot;abcd&quot;</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure>

<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/ju-zhen-zhong-de-lu-jing-lcof">https://leetcode-cn.com/problems/ju-zhen-zhong-de-lu-jing-lcof</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h6 id="知识点-30"><a href="#知识点-30" class="headerlink" title="知识点"></a>知识点</h6><p><strong>深度优先搜索（DFS）+ 剪枝</strong> 解决</p>
<ul>
<li><p>深度优先搜索： 可以理解为暴力法遍历矩阵中所有字符串可能性。DFS 通过递归，先朝一个方向搜到底，再回溯至上个节点，沿另一个方向搜索，以此类推。</p>
</li>
<li><p>剪枝： 在搜索中，遇到 <strong>这条路不可能和目标字符串匹配成功</strong> 的情况（例如：此矩阵元素和目标字符不同、此元素已被访问），则应立即返回，称之为 <strong>可行性剪枝</strong></p>
</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.leetcode-cn.com/1604944042-glmqJO-Picture0.png" alt="Picture0.png"></p>
<p><strong>递归参数</strong>： 当前元素在矩阵 board 中的行列索引 i 和 j ，当前目标字符在 word 中的索引 k 。<br><strong>终止条件</strong>：<br>返回 false ： <strong>(1) 行或列索引越界 或 (2) 当前矩阵元素与目标字符不同 或 (3) 当前矩阵元素已访问过 （ (3) 可合并至 (2) ）</strong> 。<br>返回 true ： <strong>k &#x3D; len(word) - 1 ，即字符串 word 已全部匹配。</strong><br><strong>递推工作</strong>：<br>标记当前矩阵元素： <strong>将 board[i][j]修改为 空字符 “”，代表此元素已访问过，防止之后搜索时重复访问。</strong> 搜索下一单元格： 朝当前元素的 上、下、左、右 四个方向开启下层递归，使用 或 连接 （代表只需找到一条可行路径就直接返回，不再做后续 DFS ），并记录结果至 res 。 还原当前矩阵元素： 将 board [i][j] 元素还原至初始值，即 word[k] 。<br><strong>返回值</strong>： 返回布尔量 res ，代表是否搜索到目标字符串。</p>
<p><strong>时间复杂度 O(3^KMN)</strong> 最差情况下，<strong>需要遍历矩阵中长度为 K 字符串的所有方案，时间复杂度为 O(3^K)<strong>；矩阵中共有 MN 个起点，时间复杂度为 O(MN) 。<br>方案数计算： 设字符串长度为 KK ，</strong>搜索中每个字符有上、下、左、右四个方向可以选择，舍弃回头（上个字符）的方向</strong>，剩下 3 种选择，因此方案数的复杂度为 O(3^K) 。<br>空间复杂度 O(K)： <strong>搜索过程中的递归深度不超过 K</strong> ，因此系统因函数调用累计使用的栈空间占用 O(K) （因为函数返回后，系统调用的栈空间会释放）。<strong>最坏情况下 K &#x3D; MN ，递归深度为 MN</strong> ，此时系统栈使用 O(MN) 的额外空间。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">exist0</span><span class="params">(<span class="type">char</span>[][] board, String word)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; board.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; board[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(helper(i,j,<span class="number">0</span>,board,word))<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//递归函数，指的是当前下标下的字母是否与目标字母相同</span></span><br><span class="line"><span class="comment">//k为目标字符串word下标</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">helper</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j, <span class="type">int</span> k, <span class="type">char</span>[][] board, String word)</span> &#123;</span><br><span class="line">    <span class="comment">//超过界限就剪枝，说明不能继续。</span></span><br><span class="line">    <span class="keyword">if</span> (i &gt;= board.length || i &lt; <span class="number">0</span> || j &gt;= board[<span class="number">0</span>].length || j &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断是否是可行解</span></span><br><span class="line">    <span class="keyword">if</span> (board[i][j] != word.charAt(k)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//说明找出全部字符</span></span><br><span class="line">    <span class="keyword">if</span> (k == word.length() - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将可行解的位置设置为空，防止再次进入该解</span></span><br><span class="line">    board[i][j] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">res</span> <span class="operator">=</span> helper(i - <span class="number">1</span>, j, k + <span class="number">1</span>, board, word) ||</span><br><span class="line">            helper(i + <span class="number">1</span>, j, k + <span class="number">1</span>, board, word) ||</span><br><span class="line">            helper(i, j - <span class="number">1</span>, k + <span class="number">1</span>, board, word) ||</span><br><span class="line">            helper(i, j + <span class="number">1</span>, k + <span class="number">1</span>, board, word);</span><br><span class="line">    <span class="comment">//说明递归到最后没有找到结果，往前回溯</span></span><br><span class="line">    <span class="comment">//回溯，将可行解变为原来的值</span></span><br><span class="line">    board[i][j] = word.charAt(k);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="剑指-Offer-13-机器人的运动范围"><a href="#剑指-Offer-13-机器人的运动范围" class="headerlink" title="剑指 Offer 13. 机器人的运动范围"></a>剑指 Offer 13. 机器人的运动范围</h5><p>地上有一个m行n列的方格，从坐标 [0,0] 到坐标 [m-1,n-1] 。一个机器人从坐标 [0, 0] 的格子开始移动，它每次可以向左、右、上、下移动一格（不能移动到方格外），也不能进入行坐标和列坐标的数位之和大于k的格子。例如，当k为18时，机器人能够进入方格 [35, 37] ，因为3+5+3+7&#x3D;18。但它不能进入方格 [35, 38]，因为3+5+3+8&#x3D;19。请问该机器人能够到达多少个格子？</p>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：m = 2, n = 3, k = 1</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure>

<p>示例 2：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：m = 3, n = 1, k = 0</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure>

<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof">https://leetcode-cn.com/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h6 id="知识点-31"><a href="#知识点-31" class="headerlink" title="知识点"></a>知识点</h6><p><strong>递归参数</strong>： 当前元素在矩阵中的行列索引 i 和 j ，两者的数位和 si, sj 。<br><strong>终止条件</strong>： <strong>当 ① 行列索引越界 或 ② 数位和超出目标值 k 或 ③ 当前元素已访问过 时，返回 0 ，代表不计入可达解。</strong><br><strong>递推工作</strong>：<br>    标记当前单元格 ：将索引 (i, j) 存入 Set<code>visited </code>中，代表此单元格已被访问过。<br>    搜索下一单元格： <strong>计算当前元素的 下、右 两个方向元素的数位和，并开启下层递归</strong> 。<br><strong>回溯返回值</strong>： 返回 <code>1 + 右方搜索的可达解总数 + 下方搜索的可达解总数</code>，代表从本单元格递归搜索的可达解总数。</p>
<p><strong>也可以直接往上下左右四个方向都进行递归。</strong>方便理解</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> m, n, k;</span><br><span class="line"><span class="comment">//用于表示当前元素是否被访问过</span></span><br><span class="line"><span class="type">boolean</span>[][] isvisited;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">movingCount</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.m = m;</span><br><span class="line">    <span class="built_in">this</span>.n = n;</span><br><span class="line">    <span class="built_in">this</span>.k = k;</span><br><span class="line">    isvisited = <span class="keyword">new</span> <span class="title class_">boolean</span>[m][n];</span><br><span class="line">    <span class="keyword">return</span> dfs(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">    <span class="comment">//判断是否越界</span></span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= m || j &lt; <span class="number">0</span> || j &gt;= n || help(i) + help(j) &gt; k || isvisited[i][j]) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    isvisited[i][j] = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">//向当前位置的四个方向进行递归，返回总的可达解数</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">last</span> <span class="operator">=</span> dfs(i - <span class="number">1</span>, j)</span><br><span class="line">            + dfs(i + <span class="number">1</span>, j)</span><br><span class="line">            + dfs(i, j - <span class="number">1</span>)</span><br><span class="line">            + dfs(i, j + <span class="number">1</span>);</span><br><span class="line">    <span class="comment">//成功则进行+1，即是加上当前位置</span></span><br><span class="line">    <span class="keyword">return</span> last + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//计算一个数的数位之和</span></span><br><span class="line"><span class="comment">//必须将该坐标之和的方法提取出来，否则会出现栈溢出</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">help</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        sum = sum + i % <span class="number">10</span>;</span><br><span class="line">        i = i / <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度 O(MN) ： 最差情况下，机器人遍历矩阵所有单元格，此时时间复杂度为 O(MN) 。<br>空间复杂度 O(MN) ： 最差情况下，Set visited 内存储矩阵所有单元格的索引，使用 O(MN)的额外空间。</p>
<h4 id="Day15"><a href="#Day15" class="headerlink" title="Day15"></a>Day15</h4><h5 id="剑指-Offer-34-二叉树中和为某一值的路径"><a href="#剑指-Offer-34-二叉树中和为某一值的路径" class="headerlink" title="剑指 Offer 34. 二叉树中和为某一值的路径"></a>剑指 Offer 34. 二叉树中和为某一值的路径</h5><p>给你二叉树的根节点 root 和一个整数目标和 targetSum ，找出所有 从根节点到叶子节点 路径总和等于给定目标和的路径。</p>
<p>叶子节点 是指没有子节点的节点。</p>
<p>示例 1：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://assets.leetcode.com/uploads/2021/01/18/pathsumii1.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22</span><br><span class="line">输出：[[5,4,11,2],[5,8,4,5]]</span><br></pre></td></tr></table></figure>

<p>示例 2：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://assets.leetcode.com/uploads/2021/01/18/pathsum2.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [1,2,3], targetSum = 5</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure>

<p>示例 3：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [1,2], targetSum = 0</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure>

<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/er-cha-shu-zhong-he-wei-mou-yi-zhi-de-lu-jing-lcof">https://leetcode-cn.com/problems/er-cha-shu-zhong-he-wei-mou-yi-zhi-de-lu-jing-lcof</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h6 id="知识点-32"><a href="#知识点-32" class="headerlink" title="知识点"></a>知识点</h6><p>算法流程：<br><code>pathSum(root, sum) </code>函数：</p>
<ul>
<li>初始化： 结果列表 res ，路径列表 path 。</li>
<li>返回值： 返回 res 即可。</li>
</ul>
<p>recur(root, tar) 函数：</p>
<ul>
<li><p>递推参数： 当前节点 root ，当前目标值 tar 。</p>
</li>
<li><p>终止条件： 若节点 root 为空，则直接返回。</p>
</li>
<li><p>递推工作：</p>
</li>
</ul>
<p>​	<strong>路径更新</strong>： 将当前节点值 root.val 加入路径 path ；<br>​	<strong>目标值更新</strong>： tar &#x3D; tar - root.val（即目标值 tar 从 sum 减至 00 ）；<br>​	<strong>路径记录</strong>： 当 ① root 为叶节点 且 ② 路径和等于目标值 ，则将此路径 path 加入 res 。<br>​	<strong>先序遍历</strong>： 递归左 &#x2F; 右子节点。<br>​	<strong>路径恢复</strong>： 向上回溯前，需要将当前节点从路径 path 中删除，即执行 path.pop() </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">值得注意的是，记录路径时若直接执行 res.append(path) ，则是将 path 对象加入了 res ；后续 path 改变时， res 中的 path 对象也会随之改变。</span><br><span class="line">正确做法：res.append(list(path)) ，相当于复制了一个 path 并加入到 res 。</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">LinkedList&lt;List&lt;Integer&gt;&gt; list = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">LinkedList&lt;Integer&gt; integerList = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">pathSum</span><span class="params">(TreeNode root, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    dfs(root, target);</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(TreeNode treeNode, <span class="type">int</span> sum)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (treeNode == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    integerList.add(treeNode.val);</span><br><span class="line">    sum -= treeNode.val;</span><br><span class="line">    <span class="comment">//说明找到路径，到叶子结点。</span></span><br><span class="line">    <span class="keyword">if</span> (sum == <span class="number">0</span> &amp;&amp; treeNode.left == <span class="literal">null</span> &amp;&amp; treeNode.right == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">//必须这样写，如果是list.add(integerList)。之后添加路径值会改变integerList里的值</span></span><br><span class="line">        <span class="comment">//重新创建一个就不会出现错误</span></span><br><span class="line">        list.add(<span class="keyword">new</span> <span class="title class_">LinkedList</span>(integerList));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//递归</span></span><br><span class="line">    dfs(treeNode.left, sum);</span><br><span class="line">    dfs(treeNode.right, sum);</span><br><span class="line">    <span class="comment">//路径恢复，向上回溯，需要从integerList删除节点</span></span><br><span class="line">    integerList.removeLast();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度 O(N)： N 为二叉树的节点数，先序遍历需要遍历所有节点。<br>空间复杂度 O(N) ： 最差情况下，即树退化为链表时，path 存储所有树节点，使用 O(N) 额外空间。</p>
<h5 id="剑指-Offer-54-二叉搜索树的第k大节点"><a href="#剑指-Offer-54-二叉搜索树的第k大节点" class="headerlink" title="剑指 Offer 54. 二叉搜索树的第k大节点"></a>剑指 Offer 54. 二叉搜索树的第k大节点</h5><p>给定一棵二叉搜索树，请找出其中第 k 大的节点的值。</p>
<p>示例 1:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入: root = [3,1,4,null,2], k = 1</span><br><span class="line">   3</span><br><span class="line">  / \</span><br><span class="line"> 1   4</span><br><span class="line">  \</span><br><span class="line">   2</span><br><span class="line">输出: 4</span><br></pre></td></tr></table></figure>

<p>示例 2:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入: root = [5,3,6,2,4,null,null,1], k = 3</span><br><span class="line">       5</span><br><span class="line">      / \</span><br><span class="line">     3   6</span><br><span class="line">    / \</span><br><span class="line">   2   4</span><br><span class="line">  /</span><br><span class="line"> 1</span><br><span class="line">输出: 4</span><br></pre></td></tr></table></figure>

<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-di-kda-jie-dian-lcof">https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-di-kda-jie-dian-lcof</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h6 id="知识点-33"><a href="#知识点-33" class="headerlink" title="知识点"></a>知识点</h6><p>二叉搜索树的中序遍历为 <strong>递增序列</strong> 。</p>
<p>根据以上性质，易得二叉搜索树的 中序遍历倒序 为 递减序列 。<br>因此，求 “二叉搜索树第 k 大的节点” 可转化为求 “此树的中序遍历倒序的第 k个节点”。</p>
<p>递归解析：<br><strong>终止条件</strong>： 当节点 root为空（越过叶节点），则直接返回；<br><strong>递归右子树</strong>： 即 dfs(root.right)；<br>三项工作：<br>    <strong>提前返回</strong>： 若 k &#x3D; 0 ，代表已找到目标节点，无需继续遍历，因此直接返回；<br>    <strong>统计序号</strong>： 执行 k &#x3D; k - 1 （即从 k 减至 0 ）；<br>    <strong>记录结果</strong>： 若 k &#x3D; 0 ，代表当前节点为第 kk 大的节点，因此记录 res &#x3D; root.val ；<br><strong>递归左子树</strong>： 即 dfs(root.left) ；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//逆中序遍历</span></span><br><span class="line"><span class="comment">//res 存放结果值</span></span><br><span class="line"><span class="type">int</span> res, index;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">kthLargest0</span><span class="params">(TreeNode root, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    index = k;</span><br><span class="line">    dfs(root);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs0</span><span class="params">(TreeNode treeNode)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (treeNode == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(treeNode.right);</span><br><span class="line">    <span class="comment">//表示已经找到目标，不需要在继续之后的遍历</span></span><br><span class="line">    <span class="keyword">if</span> (index == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">//--index 是先自-再使用，这个进入判断说明index此时==1</span></span><br><span class="line">    <span class="comment">//说明找到第k大的数,记录当前值</span></span><br><span class="line">    <span class="keyword">if</span> (--index == <span class="number">0</span>) &#123;</span><br><span class="line">        res = treeNode.val;</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(treeNode.left);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度 O(N)： 当树退化为链表时（全部为右子节点），无论 kk 的值大小，递归深度都为 NN ，占用 O(N) 时间。<br>空间复杂度 O(N)： 当树退化为链表时（全部为右子节点），系统使用 O(N) 大小的栈空间。</p>
<h5 id="剑指-Offer-36-二叉搜索树与双向链表"><a href="#剑指-Offer-36-二叉搜索树与双向链表" class="headerlink" title="剑指 Offer 36. 二叉搜索树与双向链表"></a>剑指 Offer 36. 二叉搜索树与双向链表</h5><p>输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的循环双向链表。要求不能创建任何新的节点，只能调整树中节点指针的指向。</p>
<p>为了让您更好地理解问题，以下面的二叉搜索树为例：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://assets.leetcode.com/uploads/2018/10/12/bstdlloriginalbst.png" alt="img"></p>
<p>我们希望将这个二叉搜索树转化为双向循环链表。链表中的每个节点都有一个前驱和后继指针。对于双向循环链表，第一个节点的前驱是最后一个节点，最后一个节点的后继是第一个节点。</p>
<p>下图展示了上面的二叉搜索树转化成的链表。“head” 表示指向链表中有最小元素的节点。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://assets.leetcode.com/uploads/2018/10/12/bstdllreturndll.png" alt="img"></p>
<p>特别地，我们希望可以就地完成转换操作。当转化完成以后，树中节点的左指针需要指向前驱，树中节点的右指针需要指向后继。还需要返回链表中的第一个节点的指针。</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-lcof">https://leetcode-cn.com/problems/er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-lcof</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h6 id="知识点-34"><a href="#知识点-34" class="headerlink" title="知识点"></a>知识点</h6><p>本文解法基于性质：二叉搜索树的中序遍历为 <strong>递增序列</strong> 。</p>
<p>算法流程：<br>dfs(cur): 递归法中序遍历；</p>
<ol>
<li>终止条件： 当节点 cur 为空，代表越过叶节点，直接返回；</li>
<li>递归左子树，即 dfs(cur.left) ；</li>
<li>构建链表：</li>
</ol>
<ul>
<li>当 pre 为空时： 代表正在访问链表头节点，记为 head ；</li>
<li>当 pre 不为空时： 修改双向节点引用，即 pre.right &#x3D; cur ， cur.left &#x3D; pre ；</li>
<li>保存 cur ： 更新 pre &#x3D; cur ，即节点 cur 是后继节点的 pre ；</li>
</ul>
<p>​	4. 递归右子树，即 dfs(cur.right) ；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//关键点：设前驱节点 pre 和当前节点 cur</span></span><br><span class="line"><span class="comment">//pre前驱节点一直保存二叉树中序遍历的前一个被访问的节点。</span></span><br><span class="line"><span class="comment">//所以中序遍历到最后pre存的一定是最后一个节点</span></span><br><span class="line"><span class="comment">//采用中序遍历二叉树，根据搜索树的性质</span></span><br><span class="line">Node pre, head;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Node <span class="title function_">treeToDoublyList</span><span class="params">(Node root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(root);</span><br><span class="line">    <span class="comment">//pre最后一定是最后一个节点</span></span><br><span class="line">    <span class="comment">//进行头结点和尾结点的互相指向，顺序可颠倒</span></span><br><span class="line">    head.left = pre;</span><br><span class="line">    pre.right = head;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(Node cur)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (cur == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//中序遍历，先左递归。在左递归之后才做操作</span></span><br><span class="line">    dfs(cur.left);</span><br><span class="line">    <span class="comment">//前驱节点为空，说明当前节点为</span></span><br><span class="line">    <span class="keyword">if</span> (pre == <span class="literal">null</span>) &#123;</span><br><span class="line">        head = cur;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//前驱结点的右指针指向后驱结点</span></span><br><span class="line">        pre.right = cur;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//左指针指向前驱结点，创建循环，即往回指</span></span><br><span class="line">    cur.left = pre;</span><br><span class="line">    <span class="comment">//保存当前结点为前驱结点</span></span><br><span class="line">    pre = cur;</span><br><span class="line">    dfs(cur.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度 O(N) ： N 为二叉树的节点数，中序遍历需要访问所有节点。<br>空间复杂度 O(N)： 最差情况下，即树退化为链表时，递归深度达到 N，系统使用 O(N) 栈空间。</p>
<h4 id="Day16"><a href="#Day16" class="headerlink" title="Day16"></a>Day16</h4><h5 id="剑指-Offer-61-扑克牌中的顺子"><a href="#剑指-Offer-61-扑克牌中的顺子" class="headerlink" title="剑指 Offer 61. 扑克牌中的顺子"></a>剑指 Offer 61. 扑克牌中的顺子</h5><p>从若干副扑克牌中随机抽 5 张牌，判断是不是一个顺子，即这5张牌是不是连续的。2～10为数字本身，A为1，J为11，Q为12，K为13，而大、小王为 0 ，可以看成任意数字。A 不能视为 14。</p>
<p>示例 1:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,2,3,4,5]</span><br><span class="line">输出: True</span><br></pre></td></tr></table></figure>


<p>示例 2:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [0,0,1,2,5]</span><br><span class="line">输出: True</span><br></pre></td></tr></table></figure>

<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/bu-ke-pai-zhong-de-shun-zi-lcof">https://leetcode-cn.com/problems/bu-ke-pai-zhong-de-shun-zi-lcof</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h6 id="知识点-35"><a href="#知识点-35" class="headerlink" title="知识点"></a>知识点</h6><p>根据题意，此 5 张牌是顺子的 充分条件 如下：</p>
<p><strong>除大小王外，所有牌 无重复 ；</strong><br>设此 5 张牌中最大的牌为 max ，最小的牌为 min （大小王除外），则需满足：<strong>max - min &lt; 5</strong></p>
<p><strong>方法一： 集合 Set + 遍历</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isStraight</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line"></span><br><span class="line">    HashSet&lt;Integer&gt; hashSet = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">    <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> <span class="number">13</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] == <span class="number">0</span>) &#123; <span class="comment">//找到大小王</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//添加元素</span></span><br><span class="line">            hashSet.add(nums[i]);</span><br><span class="line">            <span class="comment">//找到重复数直接返回</span></span><br><span class="line">            <span class="keyword">if</span> (hashSet.contains(nums[i])) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//找到最大值和最小值</span></span><br><span class="line">            min = Math.min(min, nums[i]);</span><br><span class="line">            max = Math.max(max, nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//核心就是最大值和最小值之间的差值小于5</span></span><br><span class="line">    <span class="keyword">if</span> (max - min &gt; <span class="number">5</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度 O(N) &#x3D; O(5) &#x3D; O(1)： 其中 N 为 nums 长度，本题中 N≡5 ；遍历数组使用 O(N) 时间。<br>空间复杂度 O(N) &#x3D; O(5) &#x3D; O(1) ： 用于判重的辅助 Set 使用 O(N) 额外空间。</p>
<p><strong>方法二：排序 + 遍历</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断是否是同花顺</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isStraight0</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="comment">//大小王</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">joker</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//先进行一遍排序</span></span><br><span class="line">    <span class="comment">//花费时间复杂度O(NlogN)</span></span><br><span class="line">    Arrays.sort(nums);</span><br><span class="line">    <span class="comment">//再计算大小个数和是否出现重复</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] == <span class="number">0</span>) &#123;</span><br><span class="line">            joker++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[i] == nums[i + <span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="comment">//因为进行了排序，所以直接对相邻的两个数进行比较</span></span><br><span class="line">            <span class="comment">//有重复则不满足条件</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//核心就是最大值和最小值之间的差值小于5</span></span><br><span class="line">    <span class="keyword">return</span> nums[nums.length - <span class="number">1</span>] - nums[joker] &lt; <span class="number">5</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度 O(N log N) &#x3D; O(5 log 5) &#x3D; O(1)： 其中 NN 为 nums 长度，本题中  5N≡5 ；数组排序使用 O(NlogN) 时间。<br>空间复杂度 O(1) ： 变量 jokerr 使用O(1) 大小的额外空间。</p>
<h5 id="剑指-Offer-45-把数组排成最小的数"><a href="#剑指-Offer-45-把数组排成最小的数" class="headerlink" title="剑指 Offer 45. 把数组排成最小的数"></a>剑指 Offer 45. 把数组排成最小的数</h5><p>输入一个非负整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。</p>
<p>示例 1:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [10,2]</span><br><span class="line">输出: &quot;102&quot;</span><br></pre></td></tr></table></figure>

<p>示例 2:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [3,30,34,5,9]</span><br><span class="line">输出: &quot;3033459&quot;</span><br></pre></td></tr></table></figure>

<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/ba-shu-zu-pai-cheng-zui-xiao-de-shu-lcof">https://leetcode-cn.com/problems/ba-shu-zu-pai-cheng-zui-xiao-de-shu-lcof</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h6 id="知识点-36"><a href="#知识点-36" class="headerlink" title="知识点"></a>知识点</h6><p>此题求拼接起来的最小数字，本质上是一个排序问题。设数组 nums 中任意两数字的字符串为 x 和 y ，则规定 排序判断规则 为：</p>
<p><strong>若拼接字符串 x + y &gt; y + x ，则 x “大于” y ；</strong><br><strong>反之，若 x + y &lt; y + x ，则 x “小于” y ；</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.leetcode-cn.com/95e81dbccc44f26292d88c509afd68204a86b37d342f83d109fa7aa0cd4a6049-Picture1.png" alt="Picture1.png"></p>
<p><strong>初始化</strong>： 字符串列表 strs，保存各数字的字符串格式；<br><strong>列表排序</strong>： 应用以上 “排序判断规则” ，对 strs 执行排序；<br><strong>返回值</strong>： 拼接 strs 中的所有字符串，并返回。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">minNumber</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="comment">//先将数组转化为字符串数组</span></span><br><span class="line">    String[] res = <span class="keyword">new</span> <span class="title class_">String</span>[nums.length];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        res[i] = String.valueOf(nums[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//进行快速排序</span></span><br><span class="line">    quickSort(res, <span class="number">0</span>, res.length - <span class="number">1</span>);</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">result</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    <span class="comment">//拼接结果</span></span><br><span class="line">    <span class="keyword">for</span> (String s:res) &#123;</span><br><span class="line">        result.append(s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result.toString();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">quickSort</span><span class="params">(String[] res, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">    <span class="comment">//保存原始下标</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> left;</span><br><span class="line">    <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> right;</span><br><span class="line">    <span class="type">String</span> <span class="variable">cur</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (left &gt; right) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//取一个基准点</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">temp</span> <span class="operator">=</span> res[left];</span><br><span class="line">    <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">        <span class="comment">//先从右边开始找比基准点小的</span></span><br><span class="line">        <span class="keyword">while</span> ((res[j] + temp).compareTo(temp + res[j]) &gt;= <span class="number">0</span> &amp;&amp; i &lt; j) &#123;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//从左边找比基准点大的</span></span><br><span class="line">        <span class="keyword">while</span> ((res[i] + temp).compareTo(temp + res[i]) &lt;= <span class="number">0</span> &amp;&amp; i &lt; j) &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//交换两个数</span></span><br><span class="line">        cur = res[j];</span><br><span class="line">        res[j] = res[i];</span><br><span class="line">        res[i] = cur;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//交换基准点</span></span><br><span class="line">    res[left] = res[i];</span><br><span class="line">    res[i] = temp;</span><br><span class="line">    <span class="comment">//递归</span></span><br><span class="line">    quickSort(res, left, i - <span class="number">1</span>);</span><br><span class="line">    quickSort(res, i + <span class="number">1</span>, right);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用内置函数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">minNumber0</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="comment">//先将数组转化为字符串数组</span></span><br><span class="line">    String[] res = <span class="keyword">new</span> <span class="title class_">String</span>[nums.length];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        res[i] = String.valueOf(nums[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//内置函数排序</span></span><br><span class="line">    Arrays.sort(res, (x, y) -&gt; (x + y).compareTo(y + x));</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">result</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    <span class="comment">//拼接结果</span></span><br><span class="line">    <span class="keyword">for</span> (String s : res) &#123;</span><br><span class="line">        result.append(s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度 O(NlogN) ： N 为最终返回值的字符数量（ strs 列表的长度≤N ）；<strong>使用快排或内置函数的平均时间复杂度为 O(NlogN)</strong> ，最差为 O(N^2)<br>空间复杂度 O(N)： 字符串列表 strs 占用线性大小的额外空间。</p>
<h4 id="Day17"><a href="#Day17" class="headerlink" title="Day17"></a>Day17</h4><h5 id="剑指-Offer-41-数据流中的中位数"><a href="#剑指-Offer-41-数据流中的中位数" class="headerlink" title="剑指 Offer 41. 数据流中的中位数"></a>剑指 Offer 41. 数据流中的中位数</h5><p>如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。</p>
<p>例如，</p>
<p>[2,3,4] 的中位数是 3</p>
<p>[2,3] 的中位数是 (2 + 3) &#x2F; 2 &#x3D; 2.5</p>
<p>设计一个支持以下两种操作的数据结构：</p>
<ul>
<li><p>void addNum(int num) - 从数据流中添加一个整数到数据结构中。</p>
</li>
<li><p>double findMedian() - 返回目前所有元素的中位数。</p>
</li>
</ul>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">[&quot;MedianFinder&quot;,&quot;addNum&quot;,&quot;addNum&quot;,&quot;findMedian&quot;,&quot;addNum&quot;,&quot;findMedian&quot;]</span><br><span class="line">[[],[1],[2],[],[3],[]]</span><br><span class="line">输出：[null,null,null,1.50000,null,2.00000]</span><br></pre></td></tr></table></figure>

<p>示例 2：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">[&quot;MedianFinder&quot;,&quot;addNum&quot;,&quot;findMedian&quot;,&quot;addNum&quot;,&quot;findMedian&quot;]</span><br><span class="line">[[],[2],[],[3],[]]</span><br><span class="line">输出：[null,null,2.00000,null,2.50000]</span><br></pre></td></tr></table></figure>

<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/shu-ju-liu-zhong-de-zhong-wei-shu-lcof">https://leetcode-cn.com/problems/shu-ju-liu-zhong-de-zhong-wei-shu-lcof</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h6 id="知识点-37"><a href="#知识点-37" class="headerlink" title="知识点"></a>知识点</h6><p>题目要求获取一个数据流排序后的中位数，那么可以使用两个优先队列（堆）实现。<br>该题使用<strong>一个大顶堆，一个小顶堆</strong>完成。</p>
<ul>
<li>大顶堆的每个节点的值大于等于左右孩子节点的值，堆顶为最大值。</li>
<li>小顶堆的每个节点的值小于等于左右孩子节点的值，堆顶为最小值。</li>
</ul>
<p><strong>因此我们使用 大顶堆(maxHeap) 来存储数据流中较小一半的值，用 小顶堆(minHeap) 来存储数据流中较大一半的值。</strong></p>
<p>即“大顶堆的堆顶”与“小顶堆的堆顶”就是排序数据流的两个中位数。<br>如图所示，<strong>大顶堆(maxHeap)置于下方，小顶堆(minHeap)倒置于上方</strong>，两个堆组合起来像一个沙漏的形状。<br>根据堆的性质，可以判断两个堆的值从下往上递增，即：<br><strong>maxHeap堆底 &lt;&#x3D; maxHeap堆顶 &lt;&#x3D; minHeap堆顶 &lt;&#x3D; minHeap堆底。</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.leetcode-cn.com/1638802694-YTYpGU-41-1.png" alt="41-1.png"></p>
<p>题目<strong>要求获取数据流排序后的中位数，而根据数据流的奇偶性以及堆的性质</strong>，将获取中位数的情况分为两类：</p>
<ol>
<li><p>数据流为奇数时，保证两个堆的长度相差1，那么长度较大的堆的堆顶就是中位数；</p>
</li>
<li><p>数据流为偶数时，保证两个堆的长度相等，两个堆的堆顶相加除二就是中位数。</p>
</li>
</ol>
<p><strong>那么我们要保证每次插入元素后，两堆维持相对长度。让minHeap为长度较大的堆</strong>，每次插入元素时进行判断：</p>
<ul>
<li><p>当两堆总长度为偶数时，即两堆长度相等，将新元素插入到minHeap，插入后minHeap比maxHeap长度大1；</p>
</li>
<li><p>当两堆总长度为奇数时，即两堆长度不等，将新元素插入到maxHeap，插入后两堆长度相等；</p>
</li>
</ul>
<p>还要保证插入元素后，两堆仍是保证从下往上递增的顺序性。<strong>如上面的偶数情况，将新元素x直接插入到minHeap，是有可能破坏两堆的顺序性的，例如：（minHeap是存储“较大一半”的值）</strong></p>
<ul>
<li><p>若x的值恰好为“较大一半”，直接将插入到“较大一半”的minHeap中，是不会破坏顺序的；</p>
</li>
<li><p>若x的值为“较小一半”，而此时却插入到“较大一半”的minHeap中，是会破坏顺序的。</p>
<p><strong>结论</strong></p>
</li>
<li><p><strong>当两堆总大小为偶数时，即两堆大小相等，先将新元素插入maxHeap，重新排序后将新的最值拿出并插入到minHeap；</strong></p>
</li>
<li><p><strong>当两堆总大小为奇数时，即两堆大小不等，先将新元素插入minHeap，重新排序后将新的最值拿出并插入到maxHeap；</strong></p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MedianFinder</span> &#123;</span><br><span class="line">        <span class="comment">// 大顶堆存储较小一半的值</span></span><br><span class="line">        PriorityQueue&lt;Integer&gt; maxHeap;</span><br><span class="line">        <span class="comment">// 小顶堆存储较大一般的值</span></span><br><span class="line">        PriorityQueue&lt;Integer&gt; minHeap;</span><br><span class="line">        <span class="comment">/** initialize your data structure here. */</span></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">MedianFinder</span><span class="params">()</span> &#123;</span><br><span class="line">            maxHeap = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;Integer&gt;((x, y) -&gt; (y - x));</span><br><span class="line">            minHeap = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;Integer&gt;();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addNum</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">            <span class="comment">// 长度为奇数时先放入小顶堆,重新排序后在插入到大顶堆</span></span><br><span class="line">            <span class="keyword">if</span>(maxHeap.size() != minHeap.size()) &#123;</span><br><span class="line">                minHeap.add(num);</span><br><span class="line">                maxHeap.add(minHeap.poll());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 长度为偶数时先放入大顶堆,重新排序后在插入到小顶堆</span></span><br><span class="line">                maxHeap.add(num);</span><br><span class="line">                minHeap.add(maxHeap.poll());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">findMedian</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(maxHeap.size() != minHeap.size()) &#123;</span><br><span class="line">                <span class="keyword">return</span> minHeap.peek();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> (maxHeap.peek() + minHeap.peek()) / <span class="number">2.0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>空间复杂度：O(N)，即为数据流中的元素数量。<br>时间复杂度：</p>
<ol>
<li>获取中位数：O(1)。</li>
<li>添加元素：O(logN)，堆添加元素的时间复杂度为O(logN)。</li>
</ol>
</article><div class="post-copyright"><div class="post-copyright__title"><span class="post-copyright-info"><h>剑指Offer算法学习</h></span></div><div class="post-copyright__type"><span class="post-copyright-info"><a href="https://xinkonman.github.io/2022/11/17/%E5%89%91%E6%8C%87Offer%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/">https://xinkonman.github.io/2022/11/17/剑指Offer算法学习/</a></span></div><div class="post-copyright-m"><div class="post-copyright-m-info"><div class="post-copyright-a"><h>作者</h><div class="post-copyright-cc-info"><h>xinKon</h></div></div><div class="post-copyright-c"><h>发布于</h><div class="post-copyright-cc-info"><h>2022-11-17</h></div></div><div class="post-copyright-u"><h>更新于</h><div class="post-copyright-cc-info"><h>2022-11-18</h></div></div><div class="post-copyright-c"><h>许可协议</h><div class="post-copyright-cc-info"><a class="icon" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a><a rel="noopener" target="_blank" title="CC BY-NC-SA 4.0" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a></div></div></div></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E7%AE%97%E6%B3%95/">算法</a></div><div class="post_share"><div class="social-share" data-image="https://cdn.statically.io/gh/xinKonMan/cdn/main/static/jianzhiOffer.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/2022/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"><img class="next-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.statically.io/gh/xinKonMan/cdn/main/static/bg2.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">计算机网络</div></div></a></div></nav><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.statically.io/gh/xinKonMan/cdn/main/img/anchor.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">xinKon</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">7</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">5</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">3</div></a></div><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/xinKonMan" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:842406009@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="https://space.bilibili.com/193534631?spm_id_from=333.1007.0.0" target="_blank" title="bilibili"><i class="fa-brands fa-bilibili"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">教你登dua郎</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%91%E6%8C%87Offer"><span class="toc-number">1.</span> <span class="toc-text">剑指Offer</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Day03"><span class="toc-number">1.0.1.</span> <span class="toc-text">Day03</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%89%91%E6%8C%87Offer0-5%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC"><span class="toc-number">1.0.1.1.</span> <span class="toc-text">剑指Offer0.5替换空格</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E7%82%B9"><span class="toc-number">1.0.1.1.1.</span> <span class="toc-text">知识点</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%89%91%E6%8C%87Offer58-%E5%B7%A6%E6%97%8B%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">1.0.1.2.</span> <span class="toc-text">剑指Offer58- ||.左旋转字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E7%82%B9-1"><span class="toc-number">1.0.1.2.1.</span> <span class="toc-text">知识点</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Day04"><span class="toc-number">1.0.2.</span> <span class="toc-text">Day04</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%89%91%E6%8C%87Offer03-%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97"><span class="toc-number">1.0.2.1.</span> <span class="toc-text">剑指Offer03.数组中重复的数字</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E7%82%B9-2"><span class="toc-number">1.0.2.1.1.</span> <span class="toc-text">知识点</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%89%91%E6%8C%87Offer53-%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E6%95%B0%E5%AD%97"><span class="toc-number">1.0.2.2.</span> <span class="toc-text">剑指Offer53-|.在排序数组中查找数字|</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E7%82%B9-3"><span class="toc-number">1.0.2.2.1.</span> <span class="toc-text">知识点</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%89%91%E6%8C%87-Offer-53-II-0%EF%BD%9En-1%E4%B8%AD%E7%BC%BA%E5%A4%B1%E7%9A%84%E6%95%B0%E5%AD%97"><span class="toc-number">1.0.2.3.</span> <span class="toc-text">剑指 Offer 53 - II. 0～n-1中缺失的数字</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E7%82%B9-4"><span class="toc-number">1.0.2.3.1.</span> <span class="toc-text">知识点</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Day05"><span class="toc-number">1.0.3.</span> <span class="toc-text">Day05</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%89%91%E6%8C%87-Offer-04-%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE"><span class="toc-number">1.0.3.1.</span> <span class="toc-text">剑指 Offer 04. 二维数组中的查找</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E7%82%B9-5"><span class="toc-number">1.0.3.1.1.</span> <span class="toc-text">知识点</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BA%8C%E5%88%86%E6%B3%95%EF%BC%9A"><span class="toc-number">1.0.3.2.</span> <span class="toc-text">二分法：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%89%91%E6%8C%87-Offer-11-%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97"><span class="toc-number">1.0.3.3.</span> <span class="toc-text">剑指 Offer 11. 旋转数组的最小数字</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E7%82%B9-6"><span class="toc-number">1.0.3.3.1.</span> <span class="toc-text">知识点</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%89%91%E6%8C%87-Offer-50-%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E5%AD%97%E7%AC%A6"><span class="toc-number">1.0.3.4.</span> <span class="toc-text">剑指 Offer 50. 第一次只出现一次的字符</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E7%82%B9-7"><span class="toc-number">1.0.3.4.1.</span> <span class="toc-text">知识点</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E7%82%B9-8"><span class="toc-number">1.0.3.4.2.</span> <span class="toc-text">知识点</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Day06"><span class="toc-number">1.0.4.</span> <span class="toc-text">Day06</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%89%91%E6%8C%87-Offer-32-%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">1.0.4.1.</span> <span class="toc-text">剑指 Offer 32-| 从上到下打印二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E7%82%B9-9"><span class="toc-number">1.0.4.1.1.</span> <span class="toc-text">知识点</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%89%91%E6%8C%87-Offer-32-%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91-1"><span class="toc-number">1.0.4.2.</span> <span class="toc-text">剑指 Offer 32-|| 从上到下打印二叉树 ||</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E7%82%B9-10"><span class="toc-number">1.0.4.2.1.</span> <span class="toc-text">知识点</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%89%91%E6%8C%87-Offer-32-%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91-2"><span class="toc-number">1.0.4.3.</span> <span class="toc-text">剑指 Offer 32-||| 从上到下打印二叉树 |||</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E7%82%B9-11"><span class="toc-number">1.0.4.3.1.</span> <span class="toc-text">知识点</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E7%82%B9-12"><span class="toc-number">1.0.4.3.2.</span> <span class="toc-text">知识点</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Day07"><span class="toc-number">1.0.5.</span> <span class="toc-text">Day07</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%89%91%E6%8C%87-Offer-26-%E6%A0%91%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84"><span class="toc-number">1.0.5.1.</span> <span class="toc-text">剑指 Offer 26. 树的子结构</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E7%82%B9-13"><span class="toc-number">1.0.5.1.1.</span> <span class="toc-text">知识点</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%89%91%E6%8C%87-Offer-27-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%95%9C%E5%83%8F"><span class="toc-number">1.0.5.2.</span> <span class="toc-text">剑指 Offer 27. 二叉树的镜像</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E7%82%B9-14"><span class="toc-number">1.0.5.2.1.</span> <span class="toc-text">知识点</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E7%82%B9-15"><span class="toc-number">1.0.5.2.2.</span> <span class="toc-text">知识点</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%89%91%E6%8C%87-Offer-28-%E5%AF%B9%E7%A7%B0%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">1.0.5.3.</span> <span class="toc-text">剑指 Offer 28.对称的二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E7%82%B9-16"><span class="toc-number">1.0.5.3.1.</span> <span class="toc-text">知识点</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Day08"><span class="toc-number">1.0.6.</span> <span class="toc-text">Day08</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%89%91%E6%8C%87-Offer-10-%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97"><span class="toc-number">1.0.6.1.</span> <span class="toc-text">剑指 Offer 10-|.斐波那契数列</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E7%82%B9-17"><span class="toc-number">1.0.6.1.1.</span> <span class="toc-text">知识点</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%89%91%E6%8C%87-Offer-10-%E9%9D%92%E8%9B%99%E8%B7%B3%E5%8F%B0%E9%98%B6%E9%97%AE%E9%A2%98"><span class="toc-number">1.0.6.2.</span> <span class="toc-text">剑指 Offer 10-||.青蛙跳台阶问题</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E7%82%B9-18"><span class="toc-number">1.0.6.2.1.</span> <span class="toc-text">知识点</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%89%91%E6%8C%87-Offer-63-%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E5%A4%A7%E5%88%A9%E6%B6%A6"><span class="toc-number">1.0.6.3.</span> <span class="toc-text">剑指 Offer 63.股票的最大利润</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E7%82%B9-19"><span class="toc-number">1.0.6.3.1.</span> <span class="toc-text">知识点</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Day09"><span class="toc-number">1.0.7.</span> <span class="toc-text">Day09</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%89%91%E6%8C%87Offer-42-%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C"><span class="toc-number">1.0.7.1.</span> <span class="toc-text">剑指Offer 42.连续子数组的最大和</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E7%82%B9-20"><span class="toc-number">1.0.7.1.1.</span> <span class="toc-text">知识点</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%89%91%E6%8C%87-Offer-47-%E7%A4%BC%E7%89%A9%E7%9A%84%E6%9C%80%E5%A4%A7%E4%BB%B7%E5%80%BC"><span class="toc-number">1.0.7.2.</span> <span class="toc-text">剑指 Offer 47.礼物的最大价值</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E7%82%B9-21"><span class="toc-number">1.0.7.2.1.</span> <span class="toc-text">知识点</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Daya10"><span class="toc-number">1.0.8.</span> <span class="toc-text">Daya10</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%89%91%E6%8C%87-Offer-46-%E6%8A%8A%E6%95%B0%E5%AD%97%E7%BF%BB%E8%AF%91%E6%88%90%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">1.0.8.1.</span> <span class="toc-text">剑指 Offer 46. 把数字翻译成字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E7%82%B9-22"><span class="toc-number">1.0.8.1.1.</span> <span class="toc-text">知识点</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%89%91%E6%8C%87-Offer-48-%E6%9C%80%E9%95%BF%E4%B8%8D%E5%90%AB%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">1.0.8.2.</span> <span class="toc-text">剑指 Offer 48. 最长不含重复字符的子字符串</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Day11"><span class="toc-number">1.0.9.</span> <span class="toc-text">Day11</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%89%91%E6%8C%87-Offer-18-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E8%8A%82%E7%82%B9"><span class="toc-number">1.0.9.1.</span> <span class="toc-text">剑指 Offer 18. 删除链表的节点</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E7%82%B9-23"><span class="toc-number">1.0.9.1.1.</span> <span class="toc-text">知识点</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%89%91%E6%8C%87-Offer-22-%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E8%8A%82%E7%82%B9"><span class="toc-number">1.0.9.2.</span> <span class="toc-text">剑指 Offer 22. 链表中倒数第k个节点</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E7%82%B9-24"><span class="toc-number">1.0.9.2.1.</span> <span class="toc-text">知识点</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Day12"><span class="toc-number">1.0.10.</span> <span class="toc-text">Day12</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%89%91%E6%8C%87-Offer-25-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%8E%92%E5%BA%8F%E7%9A%84%E9%93%BE%E8%A1%A8"><span class="toc-number">1.0.10.1.</span> <span class="toc-text">剑指 Offer 25. 合并两个排序的链表</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E7%82%B9-25"><span class="toc-number">1.0.10.1.1.</span> <span class="toc-text">知识点</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%89%91%E6%8C%87-Offer-52-%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%85%AC%E5%85%B1%E8%8A%82%E7%82%B9"><span class="toc-number">1.0.10.2.</span> <span class="toc-text">剑指 Offer 52. 两个链表的第一个公共节点</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E7%82%B9-26"><span class="toc-number">1.0.10.2.1.</span> <span class="toc-text">知识点</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Day13"><span class="toc-number">1.0.11.</span> <span class="toc-text">Day13</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%89%91%E6%8C%87-Offer-21-%E8%B0%83%E6%95%B4%E6%95%B0%E7%BB%84%E9%A1%BA%E5%BA%8F%E4%BD%BF%E5%A5%87%E6%95%B0%E4%BD%8D%E4%BA%8E%E5%81%B6%E6%95%B0%E5%89%8D%E9%9D%A2"><span class="toc-number">1.0.11.1.</span> <span class="toc-text">剑指 Offer 21. 调整数组顺序使奇数位于偶数前面</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E7%82%B9-27"><span class="toc-number">1.0.11.1.1.</span> <span class="toc-text">知识点</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%89%91%E6%8C%87-Offer-57-%E5%92%8C%E4%B8%BAs%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%95%B0%E5%AD%97"><span class="toc-number">1.0.11.2.</span> <span class="toc-text">剑指 Offer 57. 和为s的两个数字</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E7%82%B9-28"><span class="toc-number">1.0.11.2.1.</span> <span class="toc-text">知识点</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%89%91%E6%8C%87-Offer-58-I-%E7%BF%BB%E8%BD%AC%E5%8D%95%E8%AF%8D%E9%A1%BA%E5%BA%8F"><span class="toc-number">1.0.11.3.</span> <span class="toc-text">剑指 Offer 58 - I. 翻转单词顺序</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E7%82%B9-29"><span class="toc-number">1.0.11.3.1.</span> <span class="toc-text">知识点</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Day14"><span class="toc-number">1.0.12.</span> <span class="toc-text">Day14</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%89%91%E6%8C%87-Offer-12-%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84"><span class="toc-number">1.0.12.1.</span> <span class="toc-text">剑指 Offer 12. 矩阵中的路径</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E7%82%B9-30"><span class="toc-number">1.0.12.1.1.</span> <span class="toc-text">知识点</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%89%91%E6%8C%87-Offer-13-%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E8%BF%90%E5%8A%A8%E8%8C%83%E5%9B%B4"><span class="toc-number">1.0.12.2.</span> <span class="toc-text">剑指 Offer 13. 机器人的运动范围</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E7%82%B9-31"><span class="toc-number">1.0.12.2.1.</span> <span class="toc-text">知识点</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Day15"><span class="toc-number">1.0.13.</span> <span class="toc-text">Day15</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%89%91%E6%8C%87-Offer-34-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%92%8C%E4%B8%BA%E6%9F%90%E4%B8%80%E5%80%BC%E7%9A%84%E8%B7%AF%E5%BE%84"><span class="toc-number">1.0.13.1.</span> <span class="toc-text">剑指 Offer 34. 二叉树中和为某一值的路径</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E7%82%B9-32"><span class="toc-number">1.0.13.1.1.</span> <span class="toc-text">知识点</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%89%91%E6%8C%87-Offer-54-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E7%AC%ACk%E5%A4%A7%E8%8A%82%E7%82%B9"><span class="toc-number">1.0.13.2.</span> <span class="toc-text">剑指 Offer 54. 二叉搜索树的第k大节点</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E7%82%B9-33"><span class="toc-number">1.0.13.2.1.</span> <span class="toc-text">知识点</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%89%91%E6%8C%87-Offer-36-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%8E%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8"><span class="toc-number">1.0.13.3.</span> <span class="toc-text">剑指 Offer 36. 二叉搜索树与双向链表</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E7%82%B9-34"><span class="toc-number">1.0.13.3.1.</span> <span class="toc-text">知识点</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Day16"><span class="toc-number">1.0.14.</span> <span class="toc-text">Day16</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%89%91%E6%8C%87-Offer-61-%E6%89%91%E5%85%8B%E7%89%8C%E4%B8%AD%E7%9A%84%E9%A1%BA%E5%AD%90"><span class="toc-number">1.0.14.1.</span> <span class="toc-text">剑指 Offer 61. 扑克牌中的顺子</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E7%82%B9-35"><span class="toc-number">1.0.14.1.1.</span> <span class="toc-text">知识点</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%89%91%E6%8C%87-Offer-45-%E6%8A%8A%E6%95%B0%E7%BB%84%E6%8E%92%E6%88%90%E6%9C%80%E5%B0%8F%E7%9A%84%E6%95%B0"><span class="toc-number">1.0.14.2.</span> <span class="toc-text">剑指 Offer 45. 把数组排成最小的数</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E7%82%B9-36"><span class="toc-number">1.0.14.2.1.</span> <span class="toc-text">知识点</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Day17"><span class="toc-number">1.0.15.</span> <span class="toc-text">Day17</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%89%91%E6%8C%87-Offer-41-%E6%95%B0%E6%8D%AE%E6%B5%81%E4%B8%AD%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0"><span class="toc-number">1.0.15.1.</span> <span class="toc-text">剑指 Offer 41. 数据流中的中位数</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E7%82%B9-37"><span class="toc-number">1.0.15.1.1.</span> <span class="toc-text">知识点</span></a></li></ol></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/11/17/%E5%AE%89%E5%8D%93%E6%97%A5%E5%B8%B8%E5%AD%A6%E4%B9%A0%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/" title="安卓日常学习遇到的bug"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.statically.io/gh/xinKonMan/cdn/main/static/bg4.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="安卓日常学习遇到的bug"/></a><div class="content"><a class="title" href="/2022/11/17/%E5%AE%89%E5%8D%93%E6%97%A5%E5%B8%B8%E5%AD%A6%E4%B9%A0%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/" title="安卓日常学习遇到的bug">安卓日常学习遇到的bug</a><time datetime="2022-11-17T13:01:39.400Z" title="发表于 2022-11-17 21:01:39">2022-11-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/11/17/JobService(%E7%94%B5%E9%87%8F%E4%BC%98%E5%8C%96)/" title="JobService(电量优化)"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.statically.io/gh/xinKonMan/cdn/main/static/bg2.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="JobService(电量优化)"/></a><div class="content"><a class="title" href="/2022/11/17/JobService(%E7%94%B5%E9%87%8F%E4%BC%98%E5%8C%96)/" title="JobService(电量优化)">JobService(电量优化)</a><time datetime="2022-11-17T12:50:38.941Z" title="发表于 2022-11-17 20:50:38">2022-11-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/11/17/ConstraintLayout%20%E7%94%A8%E6%B3%95%E5%85%A8%E8%A7%A3%E6%9E%90/" title="ConstraintLayout 用法全解析"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.statically.io/gh/xinKonMan/cdn/main/static/jianzhiOffer.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="ConstraintLayout 用法全解析"/></a><div class="content"><a class="title" href="/2022/11/17/ConstraintLayout%20%E7%94%A8%E6%B3%95%E5%85%A8%E8%A7%A3%E6%9E%90/" title="ConstraintLayout 用法全解析">ConstraintLayout 用法全解析</a><time datetime="2022-11-17T12:07:47.161Z" title="发表于 2022-11-17 20:07:47">2022-11-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/11/17/%E5%AE%89%E5%8D%93%E5%AD%A6%E4%B9%A0%EF%BC%9A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81/" title="第一行代码Kotlin编程"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.statically.io/gh/xinKonMan/cdn/main/static/bg2.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="第一行代码Kotlin编程"/></a><div class="content"><a class="title" href="/2022/11/17/%E5%AE%89%E5%8D%93%E5%AD%A6%E4%B9%A0%EF%BC%9A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81/" title="第一行代码Kotlin编程">第一行代码Kotlin编程</a><time datetime="2022-11-17T11:57:58.380Z" title="发表于 2022-11-17 19:57:58">2022-11-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/11/17/%E5%AE%89%E5%8D%93%E6%97%A5%E5%B8%B8%E5%AD%A6%E4%B9%A0/" title="安卓日常学习问题记录"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.statically.io/gh/xinKonMan/cdn/main/static/bg2.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="安卓日常学习问题记录"/></a><div class="content"><a class="title" href="/2022/11/17/%E5%AE%89%E5%8D%93%E6%97%A5%E5%B8%B8%E5%AD%A6%E4%B9%A0/" title="安卓日常学习问题记录">安卓日常学习问题记录</a><time datetime="2022-11-17T11:54:42.933Z" title="发表于 2022-11-17 19:54:42">2022-11-17</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2022 By xinKon</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: 'Xj7qIyXgEQJcn7A1q4YZWB1I-gzGzoHsz',
      appKey: 'rSjPSTxWvlcwix5iJuDjXQFC',
      avatar: 'monsterid',
      serverURLs: '',
      emojiMaps: "",
      path: window.location.pathname,
      visitor: false
    }, null))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !false) {
  if (false) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script></div><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/fireworks.min.js"></script><script defer="defer" id="fluttering_ribbon" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-fluttering-ribbon.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/metingjs/dist/Meting.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><!-- hexo injector body_end start --><script data-pjax>
    function butterfly_categories_card_injector_config(){
      var parent_div_git = document.getElementById('recent-posts');
      var item_html = '<style>li.categoryBar-list-item{width:32.3%;}.categoryBar-list{max-height: 190px;overflow:auto;}.categoryBar-list::-webkit-scrollbar{width:0!important}@media screen and (max-width: 650px){.categoryBar-list{max-height: 160px;}}</style><div class="recent-post-item" style="height:auto;width:100%;padding:0px;"><div id="categoryBar"><ul class="categoryBar-list"><li class="categoryBar-list-item" style="background:url(https://cdn.statically.io/gh/xinKonMan/cdn/main/static/categories1.webp);"> <a class="categoryBar-list-link" href="categories/算法学习/">算法学习</a><span class="categoryBar-list-count">1</span><span class="categoryBar-list-descr">安卓</span></li><li class="categoryBar-list-item" style="background:url(https://cdn.statically.io/gh/xinKonMan/cdn/main/static/categories4.webp);"> <a class="categoryBar-list-link" href="categories/安卓/">安卓</a><span class="categoryBar-list-count">5</span><span class="categoryBar-list-descr">算法学习</span></li><li class="categoryBar-list-item" style="background:url(https://cdn.statically.io/gh/xinKonMan/cdn/main/static/categories2.webp);"> <a class="categoryBar-list-link" href="categories/面试准备/">面试准备</a><span class="categoryBar-list-count">1</span><span class="categoryBar-list-descr">面试准备</span></li></ul></div></div>';
      console.log('已挂载butterfly_categories_card')
      parent_div_git.insertAdjacentHTML("afterbegin",item_html)
      }
    if( document.getElementById('recent-posts') && (location.pathname ==='/'|| '/' ==='all')){
    butterfly_categories_card_injector_config()
    }
  </script><script data-pjax>
  function butterfly_footer_beautify_injector_config(){
    var parent_div_git = document.getElementById('footer-wrap');
    var item_html = '<div id="workboard"></div><p id="ghbdages"><a class="github-badge" target="_blank" href="https://hexo.io/" style="margin-inline:5px" data-title="博客框架为Hexo_v6.2.0" title=""><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Frame-Hexo-blue?style=flat&amp;logo=hexo" alt=""/></a><a class="github-badge" target="_blank" href="https://butterfly.js.org/" style="margin-inline:5px" data-title="主题版本Butterfly_v4.3.1" title=""><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Theme-Butterfly-6513df?style=flat&amp;logo=bitdefender" alt=""/></a><a class="github-badge" target="_blank" href="https://github.com/" style="margin-inline:5px" data-title="本站项目由Github托管" title=""><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Source-Github-d021d6?style=flat&amp;logo=GitHub" alt=""/></a><a class="github-badge" target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" style="margin-inline:5px" data-title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可" title=""><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Copyright-BY--NC--SA%204.0-d42328?style=flat&amp;logo=Claris" alt=""/></a></p>';
    console.log('已挂载butterfly_footer_beautify')
    parent_div_git.insertAdjacentHTML("beforeend",item_html)
    }
  var elist = 'null'.split(',');
  var cpage = location.pathname;
  var epage = 'all';
  var flag = 0;

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_footer_beautify_injector_config();
  }
  else if (epage === cpage){
    butterfly_footer_beautify_injector_config();
  }
  </script><script async src="https://cdn.statically.io/gh/xinKonMan/cdn/main/js/runtime.js"></script><!-- hexo injector body_end end --></body></html>